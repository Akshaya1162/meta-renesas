From afd15fccc7a17b047c0e2b6a4751534ccc269764 Mon Sep 17 00:00:00 2001
From: TungDang <tung.dang.jy@rvc.renesas.com>
Date: Sat, 13 Aug 2016 09:27:08 +0700
Subject: [PATCH] waylandsink: Correct coding style by gst-indent

This patch porting from the commit f06a30285e32619ac817bd83951df680116626f0 of gstreamer version 1.2.3

Porting from a patch in Linux 3.10 environment made by Kazunori Kobayashi <kkobayas@igel.co.jp>

Signed-off-by: TungDang <tung.dang.jy@rvc.renesas.com>
---
 ext/wayland/gstwaylandsink.c | 85 ++++++++++++++++++++------------------------
 ext/wayland/gstwaylandsink.h | 15 ++++----
 ext/wayland/waylandpool.h    |  3 --
 ext/wayland/wlbuffer.h       |  9 ++---
 ext/wayland/wldisplay.h      |  9 ++---
 ext/wayland/wldmabuf.h       |  4 +--
 ext/wayland/wlvideoformat.h  |  5 ++-
 ext/wayland/wlwindow.c       | 12 ++++---
 ext/wayland/wlwindow.h       | 14 ++++----
 9 files changed, 67 insertions(+), 89 deletions(-)

diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index 78b335a..2589cad 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -63,11 +63,11 @@ enum
   PROP_0,
   PROP_DISPLAY,
   PROP_USE_SUBSURFACE,
-  PROP_WAYLAND_POSITION_X,    /* add property (position_x) */
-  PROP_WAYLAND_POSITION_Y,    /* add property (position_y) */
-  PROP_WAYLAND_OUT_WIDTH,     /* add property (out_width)  */
-  PROP_WAYLAND_OUT_HEIGHT,    /* add property (out_height) */
-  PROP_FULLSCREEN             /* add property (fullscreen) */
+  PROP_WAYLAND_POSITION_X,      /* add property (position_x) */
+  PROP_WAYLAND_POSITION_Y,      /* add property (position_y) */
+  PROP_WAYLAND_OUT_WIDTH,       /* add property (out_width)  */
+  PROP_WAYLAND_OUT_HEIGHT,      /* add property (out_height) */
+  PROP_FULLSCREEN               /* add property (fullscreen) */
 };

 #define DEFAULT_USE_SUBSURFACE          TRUE
@@ -174,50 +174,34 @@ gst_wayland_sink_class_init (GstWaylandSinkClass * klass)
           "the application's surface is fullscreen)",
           DEFAULT_USE_SUBSURFACE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
   /* install property (position_x) */
-  g_object_class_install_property (G_OBJECT_CLASS(klass), PROP_WAYLAND_POSITION_X,
-      g_param_spec_int ("position_x",
-                        "Position_X",
-                        "Wayland  Position X value from the application ",
-                        0,
-                        G_MAXINT,
-                        0,
-                        G_PARAM_READWRITE));
+  g_object_class_install_property (G_OBJECT_CLASS (klass),
+      PROP_WAYLAND_POSITION_X, g_param_spec_int ("position_x", "Position_X",
+          "Wayland  Position X value from the application ", 0, G_MAXINT, 0,
+          G_PARAM_READWRITE));

   /* install property (position_y) */
-  g_object_class_install_property (G_OBJECT_CLASS(klass), PROP_WAYLAND_POSITION_Y,
-      g_param_spec_int ("position_y",
-                        "Position_Y",
-                        "Wayland  Position Y value from the application ",
-                        0,
-                        G_MAXINT,
-                        0,
-                        G_PARAM_READWRITE));
+  g_object_class_install_property (G_OBJECT_CLASS (klass),
+      PROP_WAYLAND_POSITION_Y, g_param_spec_int ("position_y", "Position_Y",
+          "Wayland  Position Y value from the application ", 0, G_MAXINT, 0,
+          G_PARAM_READWRITE));

   /* install property (out_width) */
-  g_object_class_install_property (G_OBJECT_CLASS(klass), PROP_WAYLAND_OUT_WIDTH,
-      g_param_spec_int ("out_width",
-                        "Out_width",
-                        "Wayland  Out_width value from the application",
-                        0,
-                        G_MAXINT,
-                        0,
-                        G_PARAM_READWRITE));
+  g_object_class_install_property (G_OBJECT_CLASS (klass),
+      PROP_WAYLAND_OUT_WIDTH, g_param_spec_int ("out_width", "Out_width",
+          "Wayland  Out_width value from the application", 0, G_MAXINT, 0,
+          G_PARAM_READWRITE));

   /* install property (out_height) */
-  g_object_class_install_property (G_OBJECT_CLASS(klass), PROP_WAYLAND_OUT_HEIGHT,
-      g_param_spec_int ("out_height",
-                        "Out_height",
-                        "Wayland  Out_height value from the application",
-                        0,
-                        G_MAXINT,
-                        0,
-                        G_PARAM_READWRITE));
+  g_object_class_install_property (G_OBJECT_CLASS (klass),
+      PROP_WAYLAND_OUT_HEIGHT, g_param_spec_int ("out_height", "Out_height",
+          "Wayland  Out_height value from the application", 0, G_MAXINT, 0,
+          G_PARAM_READWRITE));

   /* install property (fullscreen) */
   g_object_class_install_property (gobject_class, PROP_FULLSCREEN,
       g_param_spec_boolean ("fullscreen",
           "Fullscreen", "Display fullscreen on top of weston bar. "
-                        "Position will be at center of screen",
+          "Position will be at center of screen",
           FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE));
 }

@@ -269,7 +253,7 @@ gst_wayland_sink_get_property (GObject * object,
       g_value_set_int (value, sink->out_height);
       break;
     case PROP_FULLSCREEN:
-	  /* set fullscreen property */
+      /* set fullscreen property */
       g_value_set_boolean (value, sink->fullscreen);
       break;
     default:
@@ -595,7 +579,8 @@ gst_wayland_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
     goto pool_failed;

   structure = gst_buffer_pool_get_config (newpool);
-  gst_buffer_pool_config_set_params (structure, caps, info.size, GST_WAYLAND_BUFFER_POOL_NUM, GST_WAYLAND_BUFFER_POOL_NUM);
+  gst_buffer_pool_config_set_params (structure, caps, info.size,
+      GST_WAYLAND_BUFFER_POOL_NUM, GST_WAYLAND_BUFFER_POOL_NUM);
   gst_buffer_pool_config_set_allocator (structure, NULL, &params);
   if (!gst_buffer_pool_set_config (newpool, structure))
     goto config_failed;
@@ -681,12 +666,14 @@ gst_wayland_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query)
     size = info.size;

     config = gst_buffer_pool_get_config (pool);
-    gst_buffer_pool_config_set_params (config, caps, size, GST_WAYLAND_BUFFER_POOL_NUM, GST_WAYLAND_BUFFER_POOL_NUM);
+    gst_buffer_pool_config_set_params (config, caps, size,
+        GST_WAYLAND_BUFFER_POOL_NUM, GST_WAYLAND_BUFFER_POOL_NUM);
     if (!gst_buffer_pool_set_config (pool, config))
       goto config_failed;
   }
   if (pool) {
-    gst_query_add_allocation_pool (query, pool, size, GST_WAYLAND_BUFFER_POOL_NUM, GST_WAYLAND_BUFFER_POOL_NUM);
+    gst_query_add_allocation_pool (query, pool, size,
+        GST_WAYLAND_BUFFER_POOL_NUM, GST_WAYLAND_BUFFER_POOL_NUM);
     /*
      * Add the default allocator for the plugins that can't use dmabuf
      * descriptors.
@@ -793,18 +780,22 @@ gst_wayland_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
       /* if we were not provided a window, create one ourselves */
       /* set window position and scale */
       sink->scale = (sink->out_width << 16) | sink->out_height;
-      if ( (sink->position_x == -1) || (sink->position_y == -1) ) {
+      if ((sink->position_x == -1) || (sink->position_y == -1)) {
         sink->window =
-           gst_wl_window_new_toplevel (sink->display, &sink->video_info, sink->position_x, sink->position_y, sink->exist_position, sink->scale);
+            gst_wl_window_new_toplevel (sink->display, &sink->video_info,
+            sink->position_x, sink->position_y, sink->exist_position,
+            sink->scale);
       } else {
         sink->exist_position = 1;
         sink->window =
-           gst_wl_window_new_toplevel (sink->display, &sink->video_info, sink->position_x, sink->position_y, sink->exist_position, sink->scale);
+            gst_wl_window_new_toplevel (sink->display, &sink->video_info,
+            sink->position_x, sink->position_y, sink->exist_position,
+            sink->scale);
       }
     }
     sink->video_info_changed = FALSE;
-    if(sink->fullscreen)
-         gst_wl_window_set_fullscreen (sink->window);
+    if (sink->fullscreen)
+      gst_wl_window_set_fullscreen (sink->window);
   }

   wl_display_dispatch_queue_pending (sink->display->display, sink->frame_queue);
diff --git a/ext/wayland/gstwaylandsink.h b/ext/wayland/gstwaylandsink.h
index 025237d..ee35ba4 100644
--- a/ext/wayland/gstwaylandsink.h
+++ b/ext/wayland/gstwaylandsink.h
@@ -31,7 +31,6 @@
 #include "wlwindow.h"

 G_BEGIN_DECLS
-
 #define GST_TYPE_WAYLAND_SINK \
	    (gst_wayland_sink_get_type())
 #define GST_WAYLAND_SINK(obj) \
@@ -44,7 +43,6 @@ G_BEGIN_DECLS
	    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WAYLAND_SINK))
 #define GST_WAYLAND_SINK_GET_CLASS(inst) \
         (G_TYPE_INSTANCE_GET_CLASS ((inst), GST_TYPE_WAYLAND_SINK, GstWaylandSinkClass))
-
 typedef struct _GstWaylandSink GstWaylandSink;
 typedef struct _GstWaylandSinkClass GstWaylandSinkClass;

@@ -67,11 +65,11 @@ struct _GstWaylandSink
   GstBuffer *last_buffer;

   gboolean use_subsurface;
-  gint position_x;  /* property(position_x) */
-  gint position_y;  /* property(position_y) */
+  gint position_x;              /* property(position_x) */
+  gint position_y;              /* property(position_y) */
   gint exist_position;
-  gint out_width;   /* property out_width */
-  gint out_height;  /* property out_height */
+  gint out_width;               /* property out_width */
+  gint out_height;              /* property out_height */
   uint32_t scale;
   gboolean fullscreen;

@@ -83,8 +81,9 @@ struct _GstWaylandSinkClass
   GstVideoSinkClass parent;
 };

-GType gst_wayland_sink_get_type (void) G_GNUC_CONST;
+GType
+gst_wayland_sink_get_type (void)
+    G_GNUC_CONST;

 G_END_DECLS
-
 #endif /* __GST_WAYLAND_VIDEO_SINK_H__ */
diff --git a/ext/wayland/waylandpool.h b/ext/wayland/waylandpool.h
index 3523d24..d4cc419 100644
--- a/ext/wayland/waylandpool.h
+++ b/ext/wayland/waylandpool.h
@@ -27,13 +27,11 @@
 #include "wldisplay.h"

 G_BEGIN_DECLS
-
 #define GST_TYPE_WAYLAND_BUFFER_POOL      (gst_wayland_buffer_pool_get_type())
 #define GST_IS_WAYLAND_BUFFER_POOL(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WAYLAND_BUFFER_POOL))
 #define GST_WAYLAND_BUFFER_POOL(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WAYLAND_BUFFER_POOL, GstWaylandBufferPool))
 #define GST_WAYLAND_BUFFER_POOL_CAST(obj) ((GstWaylandBufferPool*)(obj))
 #define GST_WAYLAND_BUFFER_POOL_NUM 3
-
 typedef struct _GstWaylandBufferPool GstWaylandBufferPool;
 typedef struct _GstWaylandBufferPoolClass GstWaylandBufferPoolClass;

@@ -63,5 +61,4 @@ GType gst_wayland_buffer_pool_get_type (void);
 GstBufferPool *gst_wayland_buffer_pool_new (GstWlDisplay * display);

 G_END_DECLS
-
 #endif /*__GST_WAYLAND_BUFFER_POOL_H__*/
diff --git a/ext/wayland/wlbuffer.h b/ext/wayland/wlbuffer.h
index 4f14613..7812491 100644
--- a/ext/wayland/wlbuffer.h
+++ b/ext/wayland/wlbuffer.h
@@ -24,14 +24,12 @@
 #include "wlwindow.h"

 G_BEGIN_DECLS
-
 #define GST_TYPE_WL_BUFFER                  (gst_wl_buffer_get_type ())
 #define GST_WL_BUFFER(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WL_BUFFER, GstWlBuffer))
 #define GST_IS_WL_BUFFER(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WL_BUFFER))
 #define GST_WL_BUFFER_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_WL_BUFFER, GstWlBufferClass))
 #define GST_IS_WL_BUFFER_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_WL_BUFFER))
 #define GST_WL_BUFFER_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_WL_BUFFER, GstWlBufferClass))
-
 typedef struct _GstWlBuffer GstWlBuffer;
 typedef struct _GstWlBufferClass GstWlBufferClass;

@@ -39,7 +37,7 @@ struct _GstWlBuffer
 {
   GObject parent_instance;

-  struct wl_buffer * wlbuffer;
+  struct wl_buffer *wlbuffer;
   GstBuffer *gstbuffer;

   GstWlDisplay *display;
@@ -57,8 +55,8 @@ struct _GstWlBufferClass
 GType gst_wl_buffer_get_type (void);

 void gst_buffer_add_wl_buffer (GstBuffer * gstbuffer,
-    struct wl_buffer * wlbuffer, GstWlDisplay * display, GstWlWindow * window);
-GstWlBuffer * gst_buffer_get_wl_buffer (GstBuffer * gstbuffer,
+    struct wl_buffer *wlbuffer, GstWlDisplay * display, GstWlWindow * window);
+GstWlBuffer *gst_buffer_get_wl_buffer (GstBuffer * gstbuffer,
     GstWlWindow * window);

 void gst_wl_buffer_force_release_and_unref (GstWlBuffer * self);
@@ -66,5 +64,4 @@ void gst_wl_buffer_force_release_and_unref (GstWlBuffer * self);
 void gst_wl_buffer_attach (GstWlBuffer * self, GstWlWindow * target);

 G_END_DECLS
-
 #endif /* __GST_WL_BUFFER_H__ */
diff --git a/ext/wayland/wldisplay.h b/ext/wayland/wldisplay.h
index e1b000a..d181653 100644
--- a/ext/wayland/wldisplay.h
+++ b/ext/wayland/wldisplay.h
@@ -27,16 +27,13 @@
 #include "linux-dmabuf-client-protocol.h"

 G_BEGIN_DECLS
-
 #define GST_TYPE_WL_DISPLAY                  (gst_wl_display_get_type ())
 #define GST_WL_DISPLAY(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WL_DISPLAY, GstWlDisplay))
 #define GST_IS_WL_DISPLAY(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WL_DISPLAY))
 #define GST_WL_DISPLAY_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_WL_DISPLAY, GstWlDisplayClass))
 #define GST_IS_WL_DISPLAY_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_WL_DISPLAY))
 #define GST_WL_DISPLAY_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_WL_DISPLAY, GstWlDisplayClass))
-
 #define GST_WAYLAND_DISPLAY_CONTEXT_TYPE "GstWaylandDisplayContextType"
-
 typedef struct _GstWlDisplay GstWlDisplay;
 typedef struct _GstWlDisplayClass GstWlDisplayClass;

@@ -76,7 +73,7 @@ struct _GstWlDisplayClass
 GType gst_wl_display_get_type (void);

 GstWlDisplay *gst_wl_display_new (const gchar * name, GError ** error);
-GstWlDisplay *gst_wl_display_new_existing (struct wl_display * display,
+GstWlDisplay *gst_wl_display_new_existing (struct wl_display *display,
     gboolean take_ownership, GError ** error);

 /* see wlbuffer.c for explanation */
@@ -85,8 +82,8 @@ void gst_wl_display_register_buffer (GstWlDisplay * self, gpointer buf);
 void gst_wl_display_unregister_buffer (GstWlDisplay * self, gpointer buf);

 GstContext *gst_wl_display_context_new (GstWlDisplay * self);
-GstWlDisplay *gst_wl_display_get_context (GstContext * context, GError ** error);
+GstWlDisplay *gst_wl_display_get_context (GstContext * context,
+    GError ** error);

 G_END_DECLS
-
 #endif /* __GST_WL_DISPLAY_H__ */
diff --git a/ext/wayland/wldmabuf.h b/ext/wayland/wldmabuf.h
index 27baad7..a695d70 100644
--- a/ext/wayland/wldmabuf.h
+++ b/ext/wayland/wldmabuf.h
@@ -29,11 +29,9 @@
 #include "gstwaylandsink.h"

 G_BEGIN_DECLS
-
-GstFlowReturn
+    GstFlowReturn
 gst_wl_dmabuf_create_wl_buffer (GstWaylandSink * sink, GstBuffer * buffer,
     GstBuffer ** to_render);

 G_END_DECLS
-
 #endif /* __GST_WL_DMABUF_H__ */
diff --git a/ext/wayland/wlvideoformat.h b/ext/wayland/wlvideoformat.h
index cddc895..c1f7ba0 100644
--- a/ext/wayland/wlvideoformat.h
+++ b/ext/wayland/wlvideoformat.h
@@ -28,8 +28,8 @@
 #include <gst/video/video.h>

 G_BEGIN_DECLS
-
-enum wl_shm_format gst_video_format_to_wl_shm_format (GstVideoFormat format);
+    enum wl_shm_format gst_video_format_to_wl_shm_format (GstVideoFormat
+    format);
 GstVideoFormat gst_wl_shm_format_to_video_format (enum wl_shm_format wl_format);

 const gchar *gst_wl_shm_format_to_string (enum wl_shm_format wl_format);
@@ -41,5 +41,4 @@ GstVideoFormat gst_wl_dmabuf_format_to_video_format (guint32 wl_format);
 const gchar *gst_wl_dmabuf_format_to_string (guint32 wl_format);

 G_END_DECLS
-
 #endif
diff --git a/ext/wayland/wlwindow.c b/ext/wayland/wlwindow.c
index 8534975..c2e2210 100644
--- a/ext/wayland/wlwindow.c
+++ b/ext/wayland/wlwindow.c
@@ -121,7 +121,8 @@ gst_wl_window_new_internal (GstWlDisplay * display, struct wl_surface *surface)
 }

 GstWlWindow *
-gst_wl_window_new_toplevel (GstWlDisplay * display, GstVideoInfo * video_info, gint posx, gint posy, gint exist_pos, uint32_t scale)
+gst_wl_window_new_toplevel (GstWlDisplay * display, GstVideoInfo * video_info,
+    gint posx, gint posy, gint exist_pos, uint32_t scale)
 {
   GstWlWindow *window;

@@ -138,8 +139,9 @@ gst_wl_window_new_toplevel (GstWlDisplay * display, GstVideoInfo * video_info, g
   if (window->shell_surface) {
     wl_shell_surface_add_listener (window->shell_surface,
         &shell_surface_listener, window);
-    if (exist_pos){
-        wl_shell_surface_set_transient (window->shell_surface, window->surface, posx, posy, scale);
+    if (exist_pos) {
+      wl_shell_surface_set_transient (window->shell_surface, window->surface,
+          posx, posy, scale);
     }
     wl_shell_surface_set_toplevel (window->shell_surface);
   } else {
@@ -167,14 +169,14 @@ gst_wl_window_set_fullscreen (GstWlWindow * window)
 {
   struct wl_callback *callback;
   wl_shell_surface_set_fullscreen (window->shell_surface,
-     WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE  , 0, NULL);
+      WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE, 0, NULL);
   callback = wl_display_sync (window->display->display);
   wl_callback_add_listener (callback, &configure_callback_listener, window);
 }

 GstWlWindow *
 gst_wl_window_new_in_surface (GstWlDisplay * display,
-    struct wl_surface * parent, gboolean use_subsurface)
+    struct wl_surface *parent, gboolean use_subsurface)
 {
   GstWlWindow *window;

diff --git a/ext/wayland/wlwindow.h b/ext/wayland/wlwindow.h
index de19cd5..3290af0 100644
--- a/ext/wayland/wlwindow.h
+++ b/ext/wayland/wlwindow.h
@@ -25,14 +25,12 @@
 #include <gst/video/video.h>

 G_BEGIN_DECLS
-
 #define GST_TYPE_WL_WINDOW                  (gst_wl_window_get_type ())
 #define GST_WL_WINDOW(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WL_WINDOW, GstWlWindow))
 #define GST_IS_WL_WINDOW(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WL_WINDOW))
 #define GST_WL_WINDOW_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_WL_WINDOW, GstWlWindowClass))
 #define GST_IS_WL_WINDOW_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_WL_WINDOW))
 #define GST_WL_WINDOW_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_WL_WINDOW, GstWlWindowClass))
-
 typedef struct _GstWlWindow GstWlWindow;
 typedef struct _GstWlWindowClass GstWlWindowClass;

@@ -62,22 +60,22 @@ struct _GstWlWindowClass
 GType gst_wl_window_get_type (void);

 GstWlWindow *gst_wl_window_new_toplevel (GstWlDisplay * display,
-        GstVideoInfo * video_info, gint posx, gint posy, gint exist_pos, uint32_t scale);
+    GstVideoInfo * video_info, gint posx, gint posy, gint exist_pos,
+    uint32_t scale);
 GstWlWindow *gst_wl_window_new_in_surface (GstWlDisplay * display,
-        struct wl_surface * parent, gboolean use_subsurface);
+    struct wl_surface *parent, gboolean use_subsurface);

 GstWlDisplay *gst_wl_window_get_display (GstWlWindow * window);
 struct wl_surface *gst_wl_window_get_wl_surface (GstWlWindow * window);
-gboolean gst_wl_window_is_toplevel (GstWlWindow *window);
+gboolean gst_wl_window_is_toplevel (GstWlWindow * window);

 /* functions to manipulate the size on non-toplevel windows */
 void gst_wl_window_set_video_info (GstWlWindow * window, GstVideoInfo * info);
 void gst_wl_window_set_render_rectangle (GstWlWindow * window, gint x, gint y,
-        gint w, gint h);
+    gint w, gint h);

 /* functions for FULLSCREEN setting */
-void gst_wl_window_set_fullscreen( GstWlWindow * window);
+void gst_wl_window_set_fullscreen (GstWlWindow * window);

 G_END_DECLS
-
 #endif /* __GST_WL_WINDOW_H__ */
--
1.9.1
