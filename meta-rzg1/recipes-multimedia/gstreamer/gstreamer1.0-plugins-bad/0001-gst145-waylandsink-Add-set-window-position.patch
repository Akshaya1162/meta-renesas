From 85f1648e475877cc03abedc30bb7d8c8952e4c46 Mon Sep 17 00:00:00 2001
From: TungDang <tung.dang.jy@rvc.renesas.com>
Date: Thu, 11 Aug 2016 07:39:20 +0700
Subject: [PATCH 1/2] gst-plugins-bad-waylandsink-Add-set-window-position

Signed-off-by: TungDang <tung.dang.jy@rvc.renesas.com>
---
 ext/wayland/gstwaylandsink.c | 53 +++++++++++++++++++++++++++++++++++++++++---
 ext/wayland/gstwaylandsink.h |  3 +++
 ext/wayland/wlwindow.c       |  5 ++++-
 ext/wayland/wlwindow.h       |  2 +-
 4 files changed, 58 insertions(+), 5 deletions(-)

diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index 9bcc2d2..f0cb1ef 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -62,7 +62,9 @@ enum
 {
   PROP_0,
   PROP_DISPLAY,
-  PROP_USE_SUBSURFACE
+  PROP_USE_SUBSURFACE,
+  PROP_WAYLAND_POSITION_X,    /* add property (position_x) */
+  PROP_WAYLAND_POSITION_Y     /* add property (position_y) */
 };

 #define DEFAULT_USE_SUBSURFACE          TRUE
@@ -168,6 +170,25 @@ gst_wayland_sink_class_init (GstWaylandSinkClass * klass)
           "an externally-supplied surface (e.g. needed for scanout when "
           "the application's surface is fullscreen)",
           DEFAULT_USE_SUBSURFACE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /* install property (position_x) */
+  g_object_class_install_property (G_OBJECT_CLASS(klass), PROP_WAYLAND_POSITION_X,
+      g_param_spec_int ("position_x",
+                        "Position_X",
+                        "Wayland  Position X value from the application ",
+                        0,
+                        G_MAXINT,
+                        0,
+                        G_PARAM_READWRITE));
+
+  /* install property (position_y) */
+  g_object_class_install_property (G_OBJECT_CLASS(klass), PROP_WAYLAND_POSITION_Y,
+      g_param_spec_int ("position_y",
+                        "Position_Y",
+                        "Wayland  Position Y value from the application ",
+                        0,
+                        G_MAXINT,
+                        0,
+                        G_PARAM_READWRITE));
 }

 static void
@@ -177,6 +198,9 @@ gst_wayland_sink_init (GstWaylandSink * sink)
   g_mutex_init (&sink->render_lock);

   sink->use_subsurface = DEFAULT_USE_SUBSURFACE;
+  sink->position_x = -1;
+  sink->position_y = -1;
+  sink->exist_position = 0;
 }

 static void
@@ -194,6 +218,14 @@ gst_wayland_sink_get_property (GObject * object,
     case PROP_USE_SUBSURFACE:
       g_value_set_boolean (value, sink->use_subsurface);
       break;
+    case PROP_WAYLAND_POSITION_X:
+      /* set position_x property */
+      g_value_set_int (value, sink->position_x);
+      break;
+    case PROP_WAYLAND_POSITION_Y:
+      /* set position_y property */
+      g_value_set_int (value, sink->position_y);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -215,6 +247,14 @@ gst_wayland_sink_set_property (GObject * object,
     case PROP_USE_SUBSURFACE:
       sink->use_subsurface = g_value_get_boolean (value);
       break;
+    case PROP_WAYLAND_POSITION_X:
+      /* get position_x property */
+      sink->position_x = g_value_get_int (value);
+      break;
+    case PROP_WAYLAND_POSITION_Y:
+      /* get position_y property */
+      sink->position_y = g_value_get_int (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -695,8 +735,15 @@ gst_wayland_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
       gst_wl_window_set_video_info (sink->window, &sink->video_info);
     } else {
       /* if we were not provided a window, create one ourselves */
-      sink->window =
-          gst_wl_window_new_toplevel (sink->display, &sink->video_info);
+      /* set window position */
+      if ( (sink->position_x == -1) || (sink->position_y == -1) ) {
+        sink->window =
+           gst_wl_window_new_toplevel (sink->display, &sink->video_info, sink->position_x, sink->position_y, sink->exist_position);
+      } else {
+        sink->exist_position = 1;
+        sink->window =
+           gst_wl_window_new_toplevel (sink->display, &sink->video_info, sink->position_x, sink->position_y, sink->exist_position);
+      }
     }
     sink->video_info_changed = FALSE;
   }
diff --git a/ext/wayland/gstwaylandsink.h b/ext/wayland/gstwaylandsink.h
index df6adbe..db58452 100644
--- a/ext/wayland/gstwaylandsink.h
+++ b/ext/wayland/gstwaylandsink.h
@@ -67,6 +67,9 @@ struct _GstWaylandSink
   GstBuffer *last_buffer;

   gboolean use_subsurface;
+  gint position_x;  /* property(position_x) */
+  gint position_y;  /* property(position_y) */
+  gint exist_position;

   struct wl_event_queue *frame_queue;
 };
diff --git a/ext/wayland/wlwindow.c b/ext/wayland/wlwindow.c
index 4a1e23d..4c64d42 100644
--- a/ext/wayland/wlwindow.c
+++ b/ext/wayland/wlwindow.c
@@ -121,7 +121,7 @@ gst_wl_window_new_internal (GstWlDisplay * display, struct wl_surface *surface)
 }

 GstWlWindow *
-gst_wl_window_new_toplevel (GstWlDisplay * display, GstVideoInfo * video_info)
+gst_wl_window_new_toplevel (GstWlDisplay * display, GstVideoInfo * video_info, gint posx, gint posy, gint exist_pos)
 {
   GstWlWindow *window;

@@ -138,6 +138,9 @@ gst_wl_window_new_toplevel (GstWlDisplay * display, GstVideoInfo * video_info)
   if (window->shell_surface) {
     wl_shell_surface_add_listener (window->shell_surface,
         &shell_surface_listener, window);
+    if (exist_pos){
+        wl_shell_surface_set_transient (window->shell_surface, window->surface, posx, posy, 0);
+    }
     wl_shell_surface_set_toplevel (window->shell_surface);
   } else {
     GST_ERROR ("Unable to get wl_shell_surface");
diff --git a/ext/wayland/wlwindow.h b/ext/wayland/wlwindow.h
index 2ca1685..876f289 100644
--- a/ext/wayland/wlwindow.h
+++ b/ext/wayland/wlwindow.h
@@ -62,7 +62,7 @@ struct _GstWlWindowClass
 GType gst_wl_window_get_type (void);

 GstWlWindow *gst_wl_window_new_toplevel (GstWlDisplay * display,
-        GstVideoInfo * video_info);
+        GstVideoInfo * video_info, gint posx, gint posy, gint exist_pos);
 GstWlWindow *gst_wl_window_new_in_surface (GstWlDisplay * display,
         struct wl_surface * parent, gboolean use_subsurface);

--
1.9.1
