From d381fcae70995c49ccc22e0ffb740f4814d7deac Mon Sep 17 00:00:00 2001
From: Long Dang <long.dang.aj@rvc.renesas.com>
Date: Mon, 8 Aug 2016 16:23:53 +0700
Subject: [PATCH] uvcs-kernel-module: modified to support LTS4.4.6

Update by Huan Thai <huan.thai.xw@rvc.renesas.com>
Change device register procedure:
    - probe function of kernel module.
    - init function of kernel module.
    - interrupt handle method.
    - interrupt register api.

In details:
These are issues when porting from 3.10 to 4.4
    Issue 1: Can not request interrupt for HW IP (VCP)
    Issue 2: Can not map HW IP register (VPC)
These is a difference in register platform device for the driver:
    - The old driver use kernel API (platform_device_register())
to register it device to kernel, 
    - The new driver, device binding to driver is register by the new way 
that use the device info from <target-board>.dtb file.

Signed-off-by: Long Dang <long.dang.aj@rvc.renesas.com>
---
 uvcs/source/uvcs_lkm/uvcs_lkm.c          | 361 ++++++++++++++++---------
 uvcs/source/uvcs_lkm/uvcs_lkm_internal.h |  69 +++++
 uvcs/source/uvcs_lkm/uvcs_lkm_uf_io.c    | 436 +++++++++++++++++++++++--------
 3 files changed, 630 insertions(+), 236 deletions(-)

diff --git a/uvcs/source/uvcs_lkm/uvcs_lkm.c b/uvcs/source/uvcs_lkm/uvcs_lkm.c
index e462142..008498a 100644
--- a/uvcs/source/uvcs_lkm/uvcs_lkm.c
+++ b/uvcs/source/uvcs_lkm/uvcs_lkm.c
@@ -65,6 +65,7 @@
 /******************************************************************************/
 
 #include <linux/version.h>
+#include <linux/compat.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
@@ -81,6 +82,11 @@
 #include <linux/poll.h>
 #include <linux/vmalloc.h>
 #include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/miscdevice.h>
+#include <linux/pm_runtime.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
 #include "uvcs_types.h"
 #include "uvcs_cmn.h"
 #include "uvcs_ioctl.h"
@@ -99,7 +105,6 @@ module_param(uvcs_debug, ulong, 0);	/* debug mode for UVCS-CMN library */
 /******************************************************************************/
 MODULE_AUTHOR("Renesas Electronics");
 MODULE_LICENSE("Dual MIT/GPL");
-
 /******************************************************************************/
 /*                    VARIABLES                                               */
 /******************************************************************************/
@@ -492,6 +497,76 @@ static unsigned int uvcs_lkm_poll(struct file *filp, poll_table *wait)
 /******************************************************************************/
 /*                    device probe / remove                                   */
 /******************************************************************************/
+struct uvcs_vcp_of_data {
+	u32			 iparch;
+	char		*name;
+};
+
+static const struct uvcs_vcp_of_data vcp_of_data[] = {
+	{
+		.iparch = 0x00u,
+		.name = "vcp0",
+	},
+	{
+		.iparch = 0x02u,
+		.name = "vpc0",
+	},
+	{
+		.iparch = 0x04u,
+		.name = "vcp1",
+	},
+	{
+		.iparch = 0x06u,
+		.name = "vpc1",
+	},
+	{
+		.iparch = 0x08u,
+		.name = "vpc0xy",
+	},
+	{
+		.iparch = 0x0Au,
+		.name = "vpc1xy",
+	},
+	{
+		.iparch = 0x0Bu,
+		.name = "prr",
+	},
+	{ /* end */ }
+};
+
+static const struct of_device_id uvcs_of_match[] = {
+
+	{
+		.compatible = "renesas,vcp0",
+		.data = &vcp_of_data[0],
+	},
+	{
+		.compatible = "renesas,vpc0",
+		.data = &vcp_of_data[1],
+	},
+	{
+		.compatible = "renesas,vcp1",
+		.data = &vcp_of_data[2],
+	},
+	{
+		.compatible = "renesas,vpc1",
+		.data = &vcp_of_data[3],
+	},
+		{
+		.compatible = "renesas,vpc0xy",
+		.data = &vcp_of_data[4],
+	},
+	{
+		.compatible = "renesas,vpc1xy",
+		.data = &vcp_of_data[5],
+	},
+	{
+		.compatible = "renesas,prr",
+		.data = &vcp_of_data[6],
+	},
+	{ /* end */}
+};
+
 const struct file_operations uvcs_lkm_fops = {
 	.owner = THIS_MODULE,
 	.read = uvcs_lkm_read,
@@ -502,134 +577,99 @@ const struct file_operations uvcs_lkm_fops = {
 	.release = uvcs_lkm_release,
 };
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 static int uvcs_probe(struct platform_device *pdev)
-#else
-static int __devinit uvcs_probe(struct platform_device *pdev)
-#endif
 {
-	struct uvcs_drv_info *local;
-	int result = 0;
-	dev_t dev = 0;
-	struct device *ret_dev;
-	UVCS_CMN_INIT_PARAM_T *init;
-
-	local = kzalloc(sizeof(struct uvcs_drv_info), GFP_KERNEL);
-	if (!local) {
-		pr_debug("probe, rtn ENOMEM(1)");
-		result = -ENOMEM;
-		goto err_exit_0;
+	struct uvcs_platform_data *pdata = vzalloc(sizeof(struct uvcs_platform_data));
+	const struct of_device_id *node;
+	const struct uvcs_vcp_of_data *of_data;
+	int result = -ENODEV;
+	u32 ch;
+
+	if (!pdata)
+		return -ENOMEM;
+	node = of_match_node(uvcs_of_match, pdev->dev.of_node);
+	if (!node) {
+		dev_err(&pdev->dev, "of_match_node() failed #%d\n", __LINE__);
+		goto err_exit;
 	}
-	init = &local->uvcs_init_param;
-
-	/* get workarea size for uvcs-cmn */
-	uvcs_cmn_get_work_size(
-			&local->uvcs_lib_work_req_size,
-			&local->uvcs_hdl_work_req_size);
 
-	/* allocate workarea */
-	init->work_mem_0_size = local->uvcs_lib_work_req_size;
-	init->work_mem_0_virt = kzalloc(local->uvcs_lib_work_req_size, GFP_KERNEL);
-	if (!local->uvcs_init_param.work_mem_0_virt) {
-		pr_debug("probe, rtn ENOMEM(2)");
-		result = -ENOMEM;
-		goto err_exit_1;
-	}
+	if (node->data) {
+		of_data = (const struct uvcs_vcp_of_data *)node->data;
 
-	if (uvcs_debug) {
-		/* alloc debug buffer */
-		local->uvcs_init_param.debug_log_size = UVCS_DEBUG_BUFF_SIZE;
-		local->uvcs_init_param.debug_log_buff = vzalloc(UVCS_DEBUG_BUFF_SIZE);
-		if (!local->uvcs_init_param.debug_log_buff) {
-			pr_debug("probe, rtn ENOMEM(3)");
-			result = -ENOMEM;
-			goto err_exit_2;
+		if (0 == strcmp("vcp0",of_data->name)) {
+
+			if (of_property_read_u32(pdev->dev.of_node, "renesas,#ch", &ch) < 0) {
+			dev_err(&pdev->dev, "of_property_read_u32() failed #%d\n", __LINE__);
+			goto err_exit;
+			}
+			/* vcp */
+			if ((ch >= UVCS_VCP_DEVNUM)
+			||	(drv_info->vcpinf[ch].reg_vlc != NULL)) {
+				result = -EINVAL;
+				dev_err(&pdev->dev, "property error #%d\n", __LINE__);
+				goto err_exit;
+			}
+			pdata->device_id = drv_info->devnum;
+			pdata->device_vcp = true;
+			pdata->hwinf = &drv_info->vcpinf[ch];
+			result = uvcs_get_vcp_resource(pdev,
+					&drv_info->vcpinf[ch], of_data->iparch, of_data->name);
+			if (result)
+				goto err_exit;
+			drv_info->vcp_devnum++;
 		}
-	}
-
-	sema_init(&local->sem, 1);
-
-	result = alloc_chrdev_region(&dev, 0, DEVNUM, DRVNAME);
-	if (result) {
-		pr_debug("probe, alloc_chrdev_region");
-		goto err_exit_3;
-	}
-
-	cdev_init(&local->cdev, &uvcs_lkm_fops);
-	local->cdev.owner = THIS_MODULE;
-
-	result = cdev_add(&local->cdev, dev, DEVNUM);
-	if (result) {
-		pr_debug("probe, cdev_add");
-		goto err_exit_4;
-	}
-
-	local->pcls = class_create(THIS_MODULE, CLSNAME);
-	if (IS_ERR(local->pcls)) {
-		pr_debug("probe, class_create");
-		result = PTR_ERR(local->pcls);
-		goto err_exit_5;
-	}
-
-	ret_dev = device_create(local->pcls, NULL, dev, NULL, DEVNAME);
-	if (IS_ERR(ret_dev)) {
-		pr_debug("probe, device_create");
-		result = PTR_ERR(ret_dev);
-		goto err_exit_6;
-	}
+		if (0 == strcmp("vpc0",of_data->name)) {
+			/* vpc */
+			if (of_property_read_u32(pdev->dev.of_node, "renesas,#ch", &ch) < 0) {
+			dev_err(&pdev->dev, "of_property_read_u32() failed #%d\n", __LINE__);
+			goto err_exit;
+			}
+
+			if ((ch >= UVCS_VCP_DEVNUM)
+			||	(drv_info->vpcinf[ch].reg_vpc != NULL)) {
+				result = -EINVAL;
+				dev_err(&pdev->dev, "property error #%d\n", __LINE__);
+				goto err_exit;
+			}
+			pdata->device_id_vpc = drv_info->devnum;
+			pdata->device_vpc = true;
+			pdata->hwinf_vpc = &drv_info->vpcinf[ch];
+			result = uvcs_get_vpc_resource(pdev,
+					&drv_info->vpcinf[ch], of_data->iparch, of_data->name);
+			if (result)
+				goto err_exit;
+			drv_info->vpc_devnum++;
+		}
+	}
 
-	/* save platform_device pointer, drvdata */
-	local->pdev = pdev;
-	drv_info = local;
+	pm_suspend_ignore_children(&pdev->dev, true);
+	pm_runtime_enable(&pdev->dev);
+	pdev->dev.platform_data = pdata;
+	drv_info->pdev = pdev;
 	platform_set_drvdata(pdev, drv_info);
+	drv_info->devnum++;
 
 	return 0;
 
-err_exit_6:
-	class_destroy(local->pcls);
-
-err_exit_5:
-	cdev_del(&local->cdev);
-
-err_exit_4:
-	unregister_chrdev_region(dev, DEVNUM);
-
-err_exit_3:
-	if (local->uvcs_init_param.debug_log_buff)
-		vfree(local->uvcs_init_param.debug_log_buff);
-
-err_exit_2:
-	kfree(local->uvcs_init_param.work_mem_0_virt);
-
-err_exit_1:
-	kfree(local);
-	drv_info = NULL;
-
-err_exit_0:
+err_exit:
+	vfree(pdata);
 	return result;
-
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 static int uvcs_remove(struct platform_device *pdev)
-#else
-static int __devexit uvcs_remove(struct platform_device *pdev)
-#endif
 {
-	struct uvcs_drv_info *local = platform_get_drvdata(pdev);
-	dev_t dev = local->cdev.dev;
-
-	device_destroy(local->pcls, dev);
-	class_destroy(local->pcls);
-	cdev_del(&local->cdev);
-	unregister_chrdev_region(dev, DEVNUM);
-
-	if (local->uvcs_init_param.debug_log_buff)
-		vfree(local->uvcs_init_param.debug_log_buff);
-	kfree(local->uvcs_init_param.work_mem_0_virt);
-	kfree(local);
-	drv_info = NULL;
+	struct uvcs_platform_data *pdata = pdev->dev.platform_data;
+
+	if (!pdata)
+		return -EFAULT;
+
+	if (pdata->device_vcp)
+		uvcs_put_vcp_resource((struct uvcs_vcp_hwinf *)pdata->hwinf);
+
+	pm_runtime_disable(&pdev->dev);
+	drv_info->pdev = NULL;
 	platform_set_drvdata(pdev, NULL);
+	vfree(pdata);
 
 	return 0;
 }
@@ -644,6 +684,12 @@ static void uvcs_lkm_dev_release(struct device *dev)
 /******************************************************************************/
 /*                    module init / exit                                      */
 /******************************************************************************/
+static struct miscdevice uvcs_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVNAME,
+	.fops = &uvcs_lkm_fops
+};
+
 static int uvcs_runtime_nop(struct device *dev)
 {
 	return 0;
@@ -658,7 +704,7 @@ static const struct dev_pm_ops uvcs_pm_ops = {
 
 static struct platform_driver uvcs_driver = {
 	.probe		= uvcs_probe,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+#if 1
 	.remove		= uvcs_remove,
 #else
 	.remove		= __devexit_p(uvcs_remove),
@@ -667,9 +713,11 @@ static struct platform_driver uvcs_driver = {
 		.name	= DEVNAME ,
 		.owner	= THIS_MODULE ,
 		.pm	= &uvcs_pm_ops ,
+		.of_match_table = uvcs_of_match,
 	},
 };
 
+
 /* device resources */
 static struct resource uvcs_resources[] = {
 	/* VLC0 */
@@ -768,34 +816,93 @@ static struct platform_device uvcs_device = {
 			} ,
 };
 
-
 static int __init uvcs_module_init(void)
 {
-	int result = 0;
-
-	/* add platform device */
-	result = platform_device_register(&uvcs_device);
-	if (result)
+	int ercd;
+	u32 i;
+	drv_info = kzalloc(sizeof(struct uvcs_drv_info), GFP_KERNEL);
+	if (!drv_info) {
+		ercd = -ENOMEM;
 		goto err_exit_0;
-
-	/* register driver for platform devices */
-	result = platform_driver_register(&uvcs_driver);
-	if (result)
+	}
+	/* allocate workarea */
+	uvcs_cmn_get_work_size(&drv_info->uvcs_init_param.work_mem_0_size,
+			&drv_info->uvcs_hdl_work_req_size);
+	drv_info->uvcs_init_param.work_mem_0_virt = vzalloc(drv_info->uvcs_init_param.work_mem_0_size);
+	if (!drv_info->uvcs_init_param.work_mem_0_virt) {
+		ercd = -ENOMEM;
 		goto err_exit_1;
+	}
+
+	/* allocate debug buffer */
+	if (uvcs_debug) {
+		drv_info->uvcs_init_param.debug_log_size = UVCS_DEBUG_BUFF_SIZE;
+		drv_info->uvcs_init_param.debug_log_buff = vzalloc(UVCS_DEBUG_BUFF_SIZE);
+		if (!drv_info->uvcs_init_param.debug_log_buff) {
+			ercd = -ENOMEM;
+			goto err_exit_2;
+		}
+	}
+
+	/* register driver */
+	ercd = platform_driver_register(&uvcs_driver);
+	if (ercd)
+		goto err_exit_3;
+
+	for (i = 0; i < drv_info->vcp_devnum; i++) {
+		if (!drv_info->vcpinf[i].reg_vlc) {
+			pr_debug("uvcs: probe error #%d\n", __LINE__);
+			ercd = -ENODEV;
+			goto err_exit_4;
+		}
+	}
+
+	for (i = 0; i < drv_info->vpc_devnum; i++) {
+		if (!drv_info->vpcinf[i].reg_vpc) {
+			pr_debug("uvcs: probe error #%d\n", __LINE__);
+			ercd = -ENODEV;
+			goto err_exit_4;
+		}
+	}
+
+	ercd = misc_register(&uvcs_misc);
+	if (ercd)
+		goto err_exit_5;
+
+	sema_init(&drv_info->sem, 1);
 
 	return 0;
 
+err_exit_5:
+
+err_exit_4:
+	platform_driver_unregister(&uvcs_driver);
+
+err_exit_3:
+	if (uvcs_debug)
+		vfree(drv_info->uvcs_init_param.debug_log_buff);
+
+err_exit_2:
+	vfree(drv_info->uvcs_init_param.work_mem_0_virt);
+
 err_exit_1:
-	platform_device_unregister(&uvcs_device);
-err_exit_0:
+	kfree(drv_info);
+	drv_info = NULL;
 
-	return result;
+err_exit_0:
+	return ercd;
 }
 
 static void __exit uvcs_module_exit(void)
 {
+	misc_deregister(&uvcs_misc);
 	platform_driver_unregister(&uvcs_driver);
-	platform_device_unregister(&uvcs_device);
+
+	if (uvcs_debug)
+		vfree(drv_info->uvcs_init_param.debug_log_buff);
+	vfree(drv_info->uvcs_init_param.work_mem_0_virt);
+	kfree(drv_info);
+	drv_info = NULL;
 }
 
 module_init(uvcs_module_init);
diff --git a/uvcs/source/uvcs_lkm/uvcs_lkm_internal.h b/uvcs/source/uvcs_lkm/uvcs_lkm_internal.h
index 3f6cbde..b9141fb 100644
--- a/uvcs/source/uvcs_lkm/uvcs_lkm_internal.h
+++ b/uvcs/source/uvcs_lkm/uvcs_lkm_internal.h
@@ -132,6 +132,17 @@
 
 #define UVCS_VPCCFG_MODE	(0x00uL)
 
+#define UVCS_CLOSE_WAIT_MAX	    (10uL)	/* timeout = n * CLOSE_WAIT_TIME */
+#define UVCS_CLOSE_WAIT_TIME	(10uL)	/* msec time (sleep wait) */
+
+#define UVCS_REG_PRR            (0xFF000044u)
+#define UVCS_REG_SRCR           (0xE61500a8u)
+#define UVCS_REG_SRSTCLR        (0xE6150944u)
+
+#define UVCS_VCP_DEVNUM         (3u)
+#define UVCS_VPC_DEVNUM         (3u)
+#define UVCS_MAX_DEVNUM         (6u)
+
 /******************************************************************************/
 /*                    structures                                              */
 /******************************************************************************/
@@ -152,17 +163,52 @@ struct uvcs_hdl_info {
 	struct uvcs_req_ctrl	 req_data[UVCS_CMN_PROC_REQ_MAX];
 };
 
+struct uvcs_vpc_hwinf {
+	u32						 pa_vpc;
+	void					*reg_vpc;
+	bool					 irq_enable;
+	struct platform_device	*pdev;
+};
+
 struct uvcs_thr_ctrl {
 	struct task_struct	*thread;
 	wait_queue_head_t	 evt_wait_q;
 	bool			 evt_req;
 };
 
+struct uvcs_vcp_hwinf {
+	u32						 pa_vlc;
+	u32						 pa_ce;
+	int						 irq_vlc;
+	int						 irq_ce;
+	void					*reg_vlc;
+	void					*reg_ce;
+	char					 irq_name_vlc[64];
+	char					 irq_name_ce[64];
+	u32						 iparch;
+	u32						 ipgroup;
+	bool					 irq_enable;
+	struct platform_device	*pdev;
+	struct timer_list       timer_vlc;
+	struct timer_list       timer_ce;
+	spinlock_t              slock_vlc;
+	spinlock_t              slock_ce;
+};
+
 struct uvcs_mdl_param {
 	ulong			 lsi_type;
 	ulong			 hw_num;
 };
 
+struct uvcs_platform_data {
+	u32					 device_id;
+	bool				 device_vcp;
+	u32					 device_id_vpc;
+	bool				 device_vpc;
+	void				*hwinf;
+	void				*hwinf_vpc;
+};
+
 struct uvcs_drv_info {
 	struct platform_device	*pdev;
 	struct cdev		 cdev;
@@ -180,6 +226,11 @@ struct uvcs_drv_info {
 	UVCS_CMN_INIT_PARAM_T	 uvcs_init_param;
 	UVCS_CMN_LIB_INFO	 uvcs_info;
 	UVCS_CMN_IP_INFO_T	 ip_info;
+	u32                     devnum;
+	u32                     vcp_devnum;
+	u32                     vpc_devnum;
+	struct uvcs_vcp_hwinf   vcpinf[UVCS_VCP_DEVNUM];
+	struct uvcs_vpc_hwinf   vpcinf[UVCS_VPC_DEVNUM];
 };
 
 /******************************************************************************/
@@ -196,5 +247,23 @@ void		 uvcs_semaphore_destroy(UVCS_PTR);
 void		 uvcs_thread_event(UVCS_PTR);
 UVCS_BOOL	 uvcs_thread_create(UVCS_PTR);
 void		 uvcs_thread_destroy(UVCS_PTR);
+void         uvcs_io_deinit(struct uvcs_drv_info *drv);
+
+/* resource */
+int uvcs_get_vcp_resource(
+				struct platform_device *pdev,
+				struct uvcs_vcp_hwinf *vcpinf,
+				u32 iparch,
+				const char *name
+				);
+int uvcs_get_vpc_resource(
+				struct platform_device *pdev,
+				struct uvcs_vpc_hwinf *vpcinf,
+				u32 iparch,
+				const char *name
+				);
+void uvcs_put_vcp_resource(
+				struct uvcs_vcp_hwinf *vcpinf
+				);
 
 #endif /* UVCS_LKM_INTERNAL_H */
diff --git a/uvcs/source/uvcs_lkm/uvcs_lkm_uf_io.c b/uvcs/source/uvcs_lkm/uvcs_lkm_uf_io.c
index 35cfead..69da1d7 100644
--- a/uvcs/source/uvcs_lkm/uvcs_lkm_uf_io.c
+++ b/uvcs/source/uvcs_lkm/uvcs_lkm_uf_io.c
@@ -98,6 +98,10 @@ static struct clk *clk_vpc[UVCS_CMN_MAX_HW_NUM];
 
 ulong ip_option = UVCS_IPOPT_DEFAULT;
 module_param(ip_option, ulong, 0);
+
+static struct uvcs_drv_info *driver_info;
+static uint v_serial[UVCS_CMN_MAX_HW_NUM];
+static uint c_serial[UVCS_CMN_MAX_HW_NUM];
 /******************************************************************************/
 /*                    FORWARD DECLARATIONS                                    */
 /******************************************************************************/
@@ -112,6 +116,11 @@ static void uvcs_tasklet_3(ulong value);
 static void uvcs_vpc_setup(struct uvcs_drv_info *, UVCS_U32, UVCS_U32 *);
 static void uvcs_vpc_init(struct uvcs_drv_info *, UVCS_U32);
 
+static irqreturn_t uvcs_vlc_int_handler(int irq, void *dev);
+static irqreturn_t uvcs_ce_int_handler(int irq, void *dev);
+static int uvcs_vcp_request_irq(struct platform_device *pdev);
+static void uvcs_vcp_free_irq(struct platform_device *pdev);
+
 /************************************************************//**
  *
  * Function Name
@@ -215,6 +224,56 @@ static void uvcs_tasklet_3(ulong value)
 	}
 }
 
+static irqreturn_t uvcs_vlc_int_handler(int irq, void *dev)
+{
+	if (driver_info) {
+		struct platform_device *pdev = dev;
+		struct timespec ts;
+		int i;
+
+		getrawmonotonic(&ts);
+		for (i = 0; i < driver_info->vcp_devnum; i++) {
+			if ((driver_info->vcpinf[i].irq_vlc == irq)
+			&&	(driver_info->vcpinf[i].pdev == pdev)) {
+				spin_lock(&driver_info->vcpinf[i].slock_vlc);
+				del_timer(&driver_info->vcpinf[i].timer_vlc);
+				iowrite32(0u, driver_info->vcpinf[i].reg_vlc + UVCS_VCPREG_IRQENB);
+				uvcs_cmn_interrupt(driver_info->uvcs_info, reg_vlc[0], ts.tv_nsec);
+
+				udelay(2000);
+
+				spin_unlock(&driver_info->vcpinf[i].slock_vlc);
+				return IRQ_HANDLED;
+			}
+		}
+	}
+
+	return IRQ_NONE;
+}
+
+static irqreturn_t uvcs_ce_int_handler(int irq, void *dev)
+{
+	if (driver_info) {
+		struct platform_device *pdev = dev;
+		struct timespec ts;
+		int i;
+
+		getrawmonotonic(&ts);
+		for (i = 0; i < driver_info->vcp_devnum; i++) {
+			if ((driver_info->vcpinf[i].irq_ce == irq)
+			&&	(driver_info->vcpinf[i].pdev == pdev)) {
+				spin_lock(&driver_info->vcpinf[i].slock_ce);
+				del_timer(&driver_info->vcpinf[i].timer_ce);
+				iowrite32(0u, driver_info->vcpinf[i].reg_ce + UVCS_VCPREG_IRQENB);
+				uvcs_cmn_interrupt(driver_info->uvcs_info, reg_ce[0], ts.tv_nsec);
+				spin_unlock(&driver_info->vcpinf[i].slock_ce);
+				return IRQ_HANDLED;
+			}
+		}
+	}
+
+	return IRQ_NONE;
+}
 
 /************************************************************//**
  *
@@ -440,7 +499,7 @@ static int uvcs_remap_reg(struct uvcs_drv_info *local)
 	iounmap(regptr);
 
 	/* common */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+#if 0
 	clk_vpc[0] = devm_clk_get(&local->pdev->dev, "vpc0");
 	clk_vpc[1] = NULL;
 	clk_vcp[0] = devm_clk_get(&local->pdev->dev, "vcp0");
@@ -467,7 +526,7 @@ static int uvcs_remap_reg(struct uvcs_drv_info *local)
 	switch (regdat & UVCS_PRR_MASK_LSI) {
 	case UVCS_PRR_LSI_H2:
 		/* clock setting */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+#if 0
 		clk_vpc[1] = devm_clk_get(&local->pdev->dev, "vpc1");
 		clk_vcp[1] = devm_clk_get(&local->pdev->dev, "vcp1");
 		clk_prepare_enable(clk_vpc[1]);
@@ -543,7 +602,7 @@ static void uvcs_unmap_reg(struct uvcs_drv_info *local)
 		if (reg_vpcxy[i])
 			iounmap((void *)reg_vpcxy[i]);
 		/* stop clock */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+#if 0
 		clk_disable_unprepare(clk_vcp[i]);
 		devm_clk_put(&local->pdev->dev, clk_vcp[i]);
 #else
@@ -579,6 +638,7 @@ int uvcs_io_init(struct uvcs_drv_info *local)
 
 	if (!local)
 		goto err_exit_0;
+
 	if (uvcs_remap_reg(local))
 		goto err_exit_0;
 	iparam = &local->uvcs_init_param;
@@ -647,88 +707,20 @@ int uvcs_io_init(struct uvcs_drv_info *local)
 		local->ip_info.ip_option &= UVCS_IPOPT_H2V1_MASK;
 		local->ip_info.ip_option |= UVCS_IPOPT_H2V1_FIX;
 	}
-
-	/* install top half */
-	tasklet_init(&tl_vlc[0], uvcs_tasklet_0, (ulong)local);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-	ret = devm_request_irq(&local->pdev->dev, UVCS_INT_VLC0,
-			&uvcs_isr_0, IRQF_SHARED, "vcp3_0", &reg_vlc[0]);
-#else
-	ret = request_irq(UVCS_INT_VLC0,
-			&uvcs_isr_0, IRQF_SHARED, "vcp3_0", &reg_vlc[0]);
-#endif
-	if (ret) {
-		dev_dbg(&local->pdev->dev, "ioinit, request_irq vlc0");
-		goto err_exit_2;
-	}
-
-	tasklet_init(&tl_ce[0], uvcs_tasklet_1, (ulong)local);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-	ret = devm_request_irq(&local->pdev->dev, UVCS_INT_CE0,
-			&uvcs_isr_1, IRQF_SHARED, "vcp3_1", &reg_ce[0]);
-#else
-	ret = request_irq(UVCS_INT_CE0,
-			&uvcs_isr_1, IRQF_SHARED, "vcp3_1", &reg_ce[0]);
-#endif
-	if (ret) {
-		dev_dbg(&local->pdev->dev, "ioinit, request_irq ce0");
-		goto err_exit_3;
-	}
-
-	if (local->module_param.hw_num == 2) {
-		tasklet_init(&tl_vlc[1], uvcs_tasklet_2, (ulong)local);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-		ret = devm_request_irq(&local->pdev->dev, UVCS_INT_VLC1,
-			&uvcs_isr_2, IRQF_SHARED, "vcp3_2", &reg_vlc[1]);
-#else
-		ret = request_irq(UVCS_INT_VLC1,
-			&uvcs_isr_2, IRQF_SHARED, "vcp3_2", &reg_vlc[1]);
-#endif
-		if (ret) {
-			dev_dbg(&local->pdev->dev, "ioinit, request_irq vlc1");
-			goto err_exit_4;
-		}
-
-		tasklet_init(&tl_ce[1], uvcs_tasklet_3, (ulong)local);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-		ret = devm_request_irq(&local->pdev->dev, UVCS_INT_CE1,
-			&uvcs_isr_3, IRQF_SHARED, "vcp3_3", &reg_ce[1]);
-#else
-		ret = request_irq(UVCS_INT_CE1,
-			&uvcs_isr_3, IRQF_SHARED, "vcp3_3", &reg_ce[1]);
-#endif
-		if (ret) {
-			dev_dbg(&local->pdev->dev, "ioinit, request_irq ce1");
-			goto err_exit_5;
-		}
+
+	/* enable interrupt */
+	for (i = 0; i < local->vcp_devnum; i++) {
+		uvcs_ret = uvcs_vcp_request_irq(local->vcpinf[i].pdev);
+		if (uvcs_ret)
+			goto err_exit_3;
 	}
 
+	driver_info = local;
 	return 0;
 
-err_exit_5:
-	tasklet_kill(&tl_ce[1]);
-	tasklet_kill(&tl_vlc[1]);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-	devm_free_irq(&local->pdev->dev, UVCS_INT_VLC1, &reg_vlc[1]);
-#else
-	free_irq(UVCS_INT_VLC1, &reg_vlc[1]);
-#endif
-
-err_exit_4:
-	tasklet_kill(&tl_ce[0]);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-	devm_free_irq(&local->pdev->dev, UVCS_INT_CE0, &reg_ce[0]);
-#else
-	free_irq(UVCS_INT_CE0,  &reg_ce[0]);
-#endif
-
 err_exit_3:
-	tasklet_kill(&tl_vlc[0]);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-	devm_free_irq(&local->pdev->dev, UVCS_INT_VLC0, &reg_vlc[0]);
-#else
-	free_irq(UVCS_INT_VLC0, &reg_vlc[0]);
-#endif
+	for (; i > 0; i--)
+		uvcs_vcp_free_irq(local->vcpinf[i - 1u].pdev);
 
 err_exit_2:
 	uvcs_cmn_deinitialize(local->uvcs_info, UVCS_TRUE);
@@ -753,37 +745,263 @@ err_exit_0:
  ****************************************************************/
 void uvcs_io_cleanup(struct uvcs_drv_info *local)
 {
-	if (local) {
-		/* uninstall interrupt */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-		devm_free_irq(&local->pdev->dev,
-				UVCS_INT_VLC0, &reg_vlc[0]);
-		devm_free_irq(&local->pdev->dev,
-				UVCS_INT_CE0, &reg_ce[0]);
-#else
-		free_irq(UVCS_INT_VLC0, &reg_vlc[0]);
-		free_irq(UVCS_INT_CE0, &reg_ce[0]);
-#endif
-		tasklet_kill(&tl_vlc[0]);
-		tasklet_kill(&tl_ce[0]);
-
-		if (local->uvcs_init_param.hw_num == 2) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-			devm_free_irq(&local->pdev->dev,
-					UVCS_INT_VLC1, &reg_vlc[1]);
-			devm_free_irq(&local->pdev->dev,
-					UVCS_INT_CE1, &reg_ce[1]);
-#else
-			free_irq(UVCS_INT_VLC1, &reg_vlc[1]);
-			free_irq(UVCS_INT_CE1, &reg_ce[1]);
-#endif
-			tasklet_kill(&tl_vlc[1]);
-			tasklet_kill(&tl_ce[1]);
+	uvcs_io_deinit(local);
+}
+
+/************************************************************//**
+ *
+ * Function Name
+ *      uvcs_io_deinit
+ *
+ * Return
+ *      @return none
+ *
+ ****************************************************************/
+void uvcs_io_deinit(struct uvcs_drv_info *drv)
+{
+	u32 i;
+
+	if (drv) {
+		for (i = drv->vcp_devnum; i > 0; i--)
+			uvcs_vcp_free_irq(drv->vcpinf[i - 1u].pdev);
+		uvcs_cmn_deinitialize(drv->uvcs_info, UVCS_TRUE);
+		// for (i = drv->vcp_devnum; i > 0; i--)
+		// 	uvcs_clock_power_disable(drv->pdev[i - 1u]);
+	}
+
+	uvcs_unmap_reg(drv);
+	driver_info = NULL;
+}
+
+/******************************************************************************/
+/*              request irq                                                   */
+/******************************************************************************/
+static int uvcs_vcp_request_irq(struct platform_device *pdev)
+{
+	struct uvcs_platform_data *pdata;
+	struct uvcs_vcp_hwinf *vcpinf;
+	int result = -EFAULT;
+
+	if ((pdev == NULL)
+	||	(pdev->dev.platform_data == NULL))
+		goto err_exit_0;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata->hwinf == NULL)
+		goto err_exit_0;
+
+	vcpinf = (struct uvcs_vcp_hwinf *)pdata->hwinf;
+	vcpinf->irq_enable = false;
+	result = request_irq(vcpinf->irq_vlc,
+					&uvcs_vlc_int_handler,
+					IRQF_SHARED, vcpinf->irq_name_vlc,
+					pdev);
+	if (result) {
+		dev_err(&pdev->dev, "failed to request irq %u,v %d\n", pdata->device_id, result);
+		goto err_exit_1;
+	}
+
+	result = request_irq(vcpinf->irq_ce,
+					&uvcs_ce_int_handler,
+					IRQF_SHARED, vcpinf->irq_name_ce,
+					pdev);
+	if (result) {
+		dev_err(&pdev->dev, "failed to request irq %u,c %d\n", pdata->device_id, result);
+		goto err_exit_2;
+	}
+
+	init_timer(&vcpinf->timer_vlc);
+	init_timer(&vcpinf->timer_ce);
+	spin_lock_init(&vcpinf->slock_vlc);
+	spin_lock_init(&vcpinf->slock_ce);
+	vcpinf->irq_enable = true;
+	return 0;
+
+err_exit_2:
+	free_irq(vcpinf->irq_vlc, pdev);
+
+err_exit_1:
+err_exit_0:
+	return result;
+}
+
+static void uvcs_vcp_free_irq(struct platform_device *pdev)
+{
+	if ((pdev != NULL)
+	&&	(pdev->dev.platform_data != NULL)) {
+		struct uvcs_platform_data *pdata = pdev->dev.platform_data;
+		struct uvcs_vcp_hwinf *vcpinf = (struct uvcs_vcp_hwinf *)pdata->hwinf;
+
+		if ((vcpinf != NULL)
+		&&	(vcpinf->irq_enable)) {
+			free_irq(vcpinf->irq_vlc, pdev);
+			free_irq(vcpinf->irq_ce, pdev);
+			vcpinf->irq_enable = false;
 		}
+	}
+}
 
-		uvcs_cmn_deinitialize(local->uvcs_info, UVCS_TRUE);
-		uvcs_unmap_reg(local);
+/******************************************************************************/
+/*              resource (DT)                                                 */
+/******************************************************************************/
+int uvcs_get_vcp_resource(
+				struct platform_device *pdev,
+				struct uvcs_vcp_hwinf *vcpinf,
+				u32 iparch,
+				const char *name
+				)
+{
+	int result = -EFAULT;
+	struct resource *res;
+	int ch;
+	void __iomem *regprr;
+	u32 regdat;
+
+
+	if ((pdev == NULL) || (vcpinf == NULL))
+		goto err_exit_0;
+
+	vcpinf->reg_vlc = NULL;
+	vcpinf->reg_ce = NULL;
+	result = -ENODEV;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "resource not found (reg_0, %u)\n", iparch);
+		goto err_exit_1;
+	}
+	vcpinf->pa_vlc = (u32)res->start;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "resource not found (reg_1, %u)\n", iparch);
+		goto err_exit_1;
+	}
+	vcpinf->pa_ce = (u32)res->start;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "resource not found (irq_0, %u)\n", iparch);
+		goto err_exit_1;
+	}
+	vcpinf->irq_vlc = (int)res->start;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "resource not found (irq_1, %u)\n", iparch);
+		goto err_exit_1;
 	}
+	vcpinf->irq_ce = (int)res->start;
+
+	vcpinf->reg_vlc = ioremap_nocache(vcpinf->pa_vlc,
+									UVCS_REG_SIZE_VLC);
+
+	if (vcpinf->reg_vlc == NULL) {
+		dev_err(&pdev->dev, "failed to remap (reg_0, %u)\n", iparch);
+		goto err_exit_1;
+	}
+
+	vcpinf->reg_ce = ioremap_nocache(vcpinf->pa_ce,
+									UVCS_REG_SIZE_VPC);
+	reg_vlc[0]= vcpinf->reg_vlc;
+	reg_ce[0] = vcpinf->reg_ce;
+	reg_vlc[1] = 0;
+	reg_ce[1] = 0;
+
+	if (vcpinf->reg_ce == NULL) {
+		dev_err(&pdev->dev, "failed to remap (reg_1, %u)\n", iparch);
+		goto err_exit_2;
+	}
+
+	strcpy(vcpinf->irq_name_vlc, dev_name(&pdev->dev));
+	strcat(vcpinf->irq_name_vlc, " ");
+	strcat(vcpinf->irq_name_vlc, name);
+	strcpy(vcpinf->irq_name_ce, vcpinf->irq_name_vlc);
+	strcat(vcpinf->irq_name_vlc, ",v");
+	strcat(vcpinf->irq_name_ce, ",c");
+
+	vcpinf->iparch = iparch;
+	vcpinf->ipgroup = ch;
+	vcpinf->pdev = pdev;
+
+	return 0;
+
+err_exit_2:
+	iounmap(vcpinf->reg_vlc);
+	vcpinf->reg_vlc = NULL;
+
+err_exit_1:
+err_exit_0:
+	return result;
+}
+
+int uvcs_get_vpc_resource(
+				struct platform_device *pdev,
+				struct uvcs_vpc_hwinf *vpcinf,
+				u32 iparch,
+				const char *name
+				)
+{
+	int result = -EFAULT;
+	struct resource *res;
+	int ch;
+
+
+	if ((pdev == NULL) || (vpcinf == NULL))
+		goto err_exit_0;
+
+	vpcinf->reg_vpc = NULL;
+	result = -ENODEV;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "resource not found (reg_0, %u)\n", iparch);
+		goto err_exit_1;
+	}
+	vpcinf->pa_vpc = (u32)res->start;
+
+	clk_vpc[0] = clk_get(NULL, "vpc0");
+	clk_enable(clk_vpc[0]);
+
+
+	vpcinf->reg_vpc = ioremap_nocache(vpcinf->pa_vpc,
+									UVCS_REG_SIZE_VPC);
+
+	if (vpcinf->reg_vpc == NULL) {
+		dev_err(&pdev->dev, "failed to remap (reg_0, %u)\n", iparch);
+		goto err_exit_2;
+	}
+
+	reg_vpc[0] = vpcinf->reg_vpc;
+	reg_vpc[1] = 0;
+
+	return 0;
+
+err_exit_2:
+	iounmap(vpcinf->reg_vpc);
+	vpcinf->reg_vpc = NULL;
+
+err_exit_1:
+err_exit_0:
+	return result;
 }
 
+void uvcs_put_vcp_resource(
+			struct uvcs_vcp_hwinf *vcpinf
+			)
+{
+	if ((vcpinf)
+	&&	(vcpinf->reg_vlc)) {
+		if (vcpinf->reg_ce) {
+			iounmap(vcpinf->reg_ce);
+			vcpinf->reg_ce = NULL;
+		}
+		iounmap(vcpinf->reg_vlc);
+		vcpinf->reg_vlc = NULL;
+		if (reg_vpc[0])
+			iounmap((void *)reg_vpc[0]);
+		reg_vpc[0] = 0;
+	}
 
+
+}
-- 
1.9.1

