From 1d8fb43287db3b364a33219e8427b369736a1198 Mon Sep 17 00:00:00 2001
From: Chien Nguyen <chien.nguyen.eb@rvc.renesas.com>
Date: Sat, 6 Aug 2016 04:58:45 +0700
Subject: [PATCH] FDPM port to LTS4.4 on RZG1M

This patch file port FDPM from LTSI3.10 to LTS4.4 on RZ/G1M board

Signed-off-by: Chien Nguyen <chien.nguyen.eb@rvc.renesas.com>
---
 drv/Makefile            |   2 +-
 drv/fdp/fdp_drv.c       |  17 +--
 drv/fdpm_main.c         | 287 ++++++++++++++++--------------------------------
 drv/fdpm_sub.c          |  48 +++++---
 drv/include/fdpm_main.h |   1 +
 5 files changed, 140 insertions(+), 215 deletions(-)

diff --git a/drv/Makefile b/drv/Makefile
index 93dcbce..00874a9 100755
--- a/drv/Makefile
+++ b/drv/Makefile
@@ -7,7 +7,7 @@ fdpm-objs := $(CFILES:.c=.o)
 CP ?= cp
 
 U_INCLUDE := -I$(PWD)
-EXTRA_CFLAGS += -D$(FDPM_CONFIG)
+EXTRA_CFLAGS += -D$(FDPM_CONFIG) -Wno-date-time
 EXTRA_CFLAGS += $(U_INCLUDE)
 KERNELINC ?= $(KERNELDIR)/include/linux
 EXTRA_CFLAGS += -I$(KERNELINC)
diff --git a/drv/fdp/fdp_drv.c b/drv/fdp/fdp_drv.c
index dbefcec..537761a 100755
--- a/drv/fdp/fdp_drv.c
+++ b/drv/fdp/fdp_drv.c
@@ -365,8 +365,8 @@ long fdp_ins_init_reg(struct platform_device *pdev, int devno, T_FDPD_MEM *prv)
 		return -ENXIO;
 	}
 
-	DPRINT("res->start:%08x\n", res->start);
-	prv->mmio_res = request_mem_region(res->start, 0x2400, res->name);
+	DPRINT("print value of res->start:%08x\n", res->start);
+	prv->mmio_res = request_mem_region(res->start, 0x2400, dev_name(&pdev->dev));
 	if (prv->mmio_res == NULL) {
 		APRINT("[%s] request_mem_region failed!!\n", __func__);
 		return -ENXIO;
@@ -413,17 +413,19 @@ long fdp_ins_free_memory(T_FDPD_MEM *prv)
 
 long fdp_reg_inth(struct platform_device *pdev, int devno, T_FDPD_MEM *prv)
 {
+
 	int ercd;
+	struct resource *irq;
 
-	prv->irq = platform_get_irq(pdev, devno);
-	if (prv->irq < 0) {
+	irq = platform_get_resource(pdev, IORESOURCE_IRQ, devno);
+	if (!irq) {
 		APRINT("[%s] platform_ge_irq failed!! ercd=%d\n",
-		       __func__, prv->irq);
+		       __func__, irq);
 		return E_FDP_DEF_INH;
 	}
-
+	prv->irq = irq->start;
 	/* registory interrupt handler */
-	ercd = request_irq(prv->irq, fdp_ins_ih, IRQF_SHARED, DEVNAME, prv);
+	ercd = request_irq(prv->irq, fdp_ins_ih, IRQF_SHARED,dev_name(&pdev->dev), prv);
 	if (ercd) {
 		APRINT("[%s] request_irq failed!! ercd = %d irq=%d\n",
 		       __func__, ercd, prv->irq);
@@ -432,6 +434,7 @@ long fdp_reg_inth(struct platform_device *pdev, int devno, T_FDPD_MEM *prv)
 
 	DPRINT("done\n");
 	return 0;
+
 }
 
 long fdpm_free_inth(struct platform_device *pdev, int devno, T_FDPD_MEM *prv)
diff --git a/drv/fdpm_main.c b/drv/fdpm_main.c
index 1e4c62c..f7f2787 100755
--- a/drv/fdpm_main.c
+++ b/drv/fdpm_main.c
@@ -69,6 +69,9 @@
 #include <linux/semaphore.h>
 #include <linux/fs.h>
 #include <linux/pm_runtime.h>
+#include <linux/miscdevice.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
 
 #include "fdpm_api.h"
 #include "fdpm_if_par.h"
@@ -84,16 +87,13 @@
 
 #define gic_spi(n) ((n)+32)
 
+static int fdpm_fdp_probe(struct platform_device *pdev);
+static int fdpm_fdp_remove(struct platform_device *pdev);
+static int fdpm_runtime_nop(struct device *dev);
 static int fdpm_open(struct inode *inode, struct file *filp);
+
 static long drv_FDPM_release(unsigned long handle);
 static int fdpm_close(struct inode *inode, struct file *filp);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-static int fdpm_remove(struct platform_device *pdev);
-static int fdpm_probe(struct platform_device *pdev);
-#else
-static int __devexit fdpm_remove(struct platform_device *pdev);
-static int __devinit fdpm_probe(struct platform_device *pdev);
-#endif
 
 /* banner */
 #ifdef H2CONFIG
@@ -112,6 +112,45 @@ static char banner[] __initdata = KERN_INFO DRVNAME
 	"driver for E2 installed";
 #endif
 
+static const struct dev_pm_ops fdpm_pm_ops = {
+	.runtime_suspend = fdpm_runtime_nop,
+	.runtime_resume = fdpm_runtime_nop,
+	.suspend = fdpm_runtime_nop,
+	.resume = fdpm_runtime_nop,
+};
+
+static const struct of_device_id fdpm_fdp_of_match[] = {
+	{
+		.compatible = "renesas,fdp1"
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, fdpm_fdp_of_match);
+
+/* fdpm driver platform-data */
+static struct platform_driver fdpm_driver = {
+	.probe		= fdpm_fdp_probe,
+	.remove		= fdpm_fdp_remove,
+	.driver		= {
+		.name		= DRVNAME, /* DRVNAME */
+		.owner		= THIS_MODULE,
+		.pm		= &fdpm_pm_ops,
+		.of_match_table = fdpm_fdp_of_match,
+	},
+};
+
+static const struct file_operations fdpm_fops = {
+	.owner			= THIS_MODULE,
+	.unlocked_ioctl		= fdpm_ioctl,
+	.open			= fdpm_open,
+	.release		= fdpm_close,
+};
+
+static struct miscdevice fdpm_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVNAME,
+	.fops = &fdpm_fops
+};
 /* major device number */
 static int major;
 module_param(major, int, 0);
@@ -121,55 +160,6 @@ struct fdpm_drvdata *p_fdpm_drvdata;
 
 static long fdpm_handle;
 static unsigned long g_open_id;
-/* platform device */
-static struct resource fdpm_resources[] = {
-	[0] = {
-	.name  = RESNAME "-fdp0",
-	.start = 0xFE940000,
-	.end   = 0xFE942400 - 1,
-	.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-	.name  = RESNAME "-fdp0",
-	.start = gic_spi(262),
-	.flags = IORESOURCE_IRQ,
-	},
-	[2] = {
-	.name  = RESNAME "-fdp1",
-	.start = 0xFE944000,
-	.end   = 0xFE946400 - 1,
-	.flags = IORESOURCE_MEM,
-	},
-	[3] = {
-	.name  = RESNAME "-fpd1",
-	.start = gic_spi(263),
-	.flags = IORESOURCE_IRQ,
-	},
-	[4] = {
-	.name  = RESNAME "-fdp2",
-	.start = 0xFE948000,
-	.end   = 0XFE94A400 - 1,
-	.flags = IORESOURCE_MEM,
-	},
-	[5] = {
-	.name  = RESNAME "-fdp2",
-	.start = gic_spi(264),
-	.flags = IORESOURCE_IRQ,
-	},
-};
-
-static const struct file_operations fdpm_fops = {
-	.owner          = THIS_MODULE,
-	.unlocked_ioctl = fdpm_ioctl,
-	.open           = fdpm_open,
-	.release        = fdpm_close,
-};
-
-static void fdpm_dev_release(struct device *dev)
-{
-	DPRINT("do not do anything\n");
-	return;
-}
 
 static int fdpm_runtime_nop(struct device *dev)
 {
@@ -183,39 +173,6 @@ static int fdpm_runtime_nop(struct device *dev)
 	return 0;
 }
 
-static const struct dev_pm_ops fdpm_pm_ops = {
-	.runtime_suspend = fdpm_runtime_nop,
-	.runtime_resume = fdpm_runtime_nop,
-	.suspend = fdpm_runtime_nop,
-	.resume = fdpm_runtime_nop,
-};
-
-/* fdpm driver platform-data */
-static struct platform_driver fdpm_driver = {
-	.driver = {
-	.name = DRVNAME,
-	.owner = THIS_MODULE,
-	.pm = &fdpm_pm_ops,
-	},
-	.probe = fdpm_probe,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-	.remove = fdpm_remove,
-#else
-	.remove = __devexit_p(fdpm_remove),
-#endif
-};
-
-static struct platform_device fdpm_device = {
-	.name          = DEVNAME,
-	.id            = -1,
-	.resource      = fdpm_resources,
-	.num_resources = ARRAY_SIZE(fdpm_resources),
-	.dev           = {
-	.release       = fdpm_dev_release,
-	},
-};
-
-
 long FDPM_lib_DriverInitialize(unsigned long *handle)
 {
 	int ret;
@@ -333,26 +290,18 @@ static int fdpm_close(struct inode *inode, struct file *filp)
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-static int fdpm_remove(struct platform_device *pdev)
-#else
-static int __devexit fdpm_remove(struct platform_device *pdev)
-#endif
+static int fdpm_fdp_remove(struct platform_device *pdev)
 {
-	struct fdpm_drvdata *pdrv = platform_get_drvdata(pdev);
-	dev_t               dev   = pdrv->cdev.dev;
-
-	DPRINT("called(id=%d)\n", pdev->id);
-
-	/* remove a device that was created sith device_create() */
-	device_destroy(pdrv->pcls, dev);
-	/* destroys a struct class structure */
-	class_destroy(pdrv->pcls);
-	/* remove a cdev from the system */
-	cdev_del(&pdrv->cdev);
-	unregister_chrdev_region(dev, DEVNUM);
-	kfree(pdrv);
+	struct fdpm_drvdata *pdrv = p_fdpm_drvdata;
+	struct device_node *np = pdev->dev.of_node;
+
+	DPRINT("fdpm_fdp_remove. called(id=%d)\n", pdev->id);
+
+	pm_runtime_disable(&pdev->dev);
+
+	/* unset driver data */
 	platform_set_drvdata(pdev, NULL);
+	pdrv->pdev = NULL;
 
 	DPRINT("done(id=%d)\n", pdev->id);
 	return 0;
@@ -414,80 +363,39 @@ exit:
 }
 #endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-static int fdpm_probe(struct platform_device *pdev)
-#else
-static int __devinit fdpm_probe(struct platform_device *pdev)
-#endif
+static int fdpm_fdp_probe(struct platform_device *pdev)
 {
-	dev_t               dev   = 0;
-	struct fdpm_drvdata *pdrv = 0;
-	struct device       *ret_dev;
+	struct device *dev = &pdev->dev;
 	int                 ret   = 0;
+	static int channel = 0;
 
-	DPRINT("called(id=%d)\n", pdev->id);
+	const struct device_node *node = pdev->dev.of_node;
+	struct fdpm_drvdata *pdrv;
 
-	/* allocate fdpm driver data area */
-	pdrv = kzalloc(sizeof(struct fdpm_drvdata), GFP_KERNEL);
-	if (!pdrv) {
-		APRINT("could not allocate fdpm driver data area (id=%d)\n",
-		       pdev->id);
-		ret = -ENOMEM;
-		goto exit;
-	}
+	DPRINT("This is module probe - START - %s %d\n",__func__,__LINE__);
 
-	/* register a range of char device numbers */
-	if (major) {
-		dev = MKDEV(major, 0);
-		ret = register_chrdev_region(dev, DEVNUM, DRVNAME);
-		if (ret) {
-			APRINT("could not get major %d (dev=%x)\n", ret, dev);
-			dev = 0;
-			goto exit;
-		}
-	} else {
-		ret = alloc_chrdev_region(&dev, 0, DEVNUM, DRVNAME);
-		if (ret) {
-			APRINT("could not allocate major %d\n", ret);
-			goto exit;
-		}
-		major = MAJOR(dev);
-	}
-	DPRINT("major:%d\n", major);
-
-	/* initialize a cdev structure */
-	cdev_init(&pdrv->cdev, &fdpm_fops);
-	pdrv->cdev.owner = THIS_MODULE;
+	if(p_fdpm_drvdata == NULL){
+		EPRINT("p_fdpm_drvdata is NULL\n");
+		return -ENOMEM;;
 
-	/* add a char device to the system */
-	ret = cdev_add(&pdrv->cdev, dev, DEVNUM);
-	if (ret) {
-		APRINT("could not add a char device %d (dev=%x)\n", ret, dev);
-		goto exit;
 	}
 
-	/* create a struct class structure */
-	pdrv->pcls = class_create(THIS_MODULE, CLSNAME);
-	if (IS_ERR(pdrv->pcls)) {
-		APRINT("could not create a class\n");
-		ret = PTR_ERR(pdrv->pcls);
-		pdrv->pcls = 0;
-		goto exit;
-	}
+	pdrv = p_fdpm_drvdata;
+
+	node = of_match_node(fdpm_fdp_of_match, pdev->dev.of_node);
 
-	/* creates a device and registers it with sysfs */
-	ret_dev = device_create(pdrv->pcls, NULL, dev, NULL, DEVNAME);
-	if (IS_ERR(ret_dev)) {
-		APRINT("could not create a device\n");
-		ret = PTR_ERR(ret_dev);
+	if (!node) {
+		DPRINT("of_match_node() failed #%d\n", __LINE__);
 		goto exit;
+	} else {
+		DPRINT("of_match_node() Success #%d\n", __LINE__);
 	}
 
-	/* initialize open counter */
-	atomic_set(&pdrv->counter, 0);
-
 	/* save platform_device_pointer */
-	pdrv->pdev = pdev;
+	if (channel == 0)
+		pdrv->pdev = pdev;
+	if (channel == 1)
+		pdrv->pdev_c2 = pdev;
 
 	sema_init(&pdrv->resource_sem, 1); /* unlock */
 	sema_init(&pdrv->init_sem, 1);/* unlock */
@@ -501,6 +409,7 @@ static int __devinit fdpm_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, pdrv);
 
 	DPRINT("done(id=%d)\n", pdev->id);
+	channel++;
 	return 0;
 
 exit:
@@ -523,33 +432,26 @@ static int __init fdpm_module_init(void)
 
 	DPRINT("called\n");
 
-	ret = platform_device_register(&fdpm_device);
-	if (ret) {
-		APRINT("could not add a platform-level device %d\n", ret);
-		goto exit;
+	/* allocate fdpm driver data area */
+	p_fdpm_drvdata = kzalloc(sizeof(struct fdpm_drvdata), GFP_KERNEL);
+	if (!p_fdpm_drvdata) {
+		APRINT("could not allocate fdpm driver data area\n");
+		return -ENOMEM;
 	}
 
 	ret = platform_driver_register(&fdpm_driver);
 	if (ret) {
 		APRINT("could not register a driver for ");
 		APRINT("platform-level devices %d\n", ret);
-		platform_device_unregister(&fdpm_device);
-		goto exit;
+		p_fdpm_drvdata = NULL;
+		return ret;
 	}
+
+	ret = misc_register(&fdpm_misc);
 
-#ifdef DEBUG
-	/* make a directory /proc/driver/fdpm */
-	proc_dir = proc_mkdir(PROCNAME, NULL);
-	if (!proc_dir)
-		APRINT("could not make a proc dir\n");
-
-	/* make a proc entry /proc/driver/vspm/DEBUG */
-	proc_debug_entry = create_proc_entry(PROCNAME_DEBUG, 0666, proc_dir);
-	if (!proc_debug_entry)
-		APRINT("could not make a proc entry\n");
-	proc_debug_entry->read_proc = fdpm_proc_read_debug;
-	proc_debug_entry->write_proc = fdpm_proc_write_debug;
-#endif
+	if (ret){
+		APRINT("misc_register Fail");
+	}
 
 	wret = FDPM_lib_DriverInitialize((unsigned long *)&fdpm_handle);
 	if (wret != R_FDPM_OK) {
@@ -570,19 +472,16 @@ static void __exit fdpm_module_exit(void)
 {
 	long wret;
 	DPRINT("called\n");
+
+	misc_deregister(&fdpm_misc);
 
 	wret = drv_FDPM_release(fdpm_handle);
 	if (wret != R_FDPM_OK)
 		APRINT("failed to drv_FDPM_release %d\n", (int)wret);
 
 	platform_driver_unregister(&fdpm_driver);
-	platform_device_unregister(&fdpm_device);
-#ifdef DEBUG
-	if (proc_debug_entry)
-		remove_proc_entry(PROCNAME_DEBUG, proc_dir);
-	if (proc_dir)
-		remove_proc_entry(PROCNAME, NULL);
-#endif
+	kfree(p_fdpm_drvdata);
+	p_fdpm_drvdata = NULL;
 	DPRINT("done\n");
 	return;
 }
diff --git a/drv/fdpm_sub.c b/drv/fdpm_sub.c
index ba7731e..daceed5 100755
--- a/drv/fdpm_sub.c
+++ b/drv/fdpm_sub.c
@@ -145,6 +145,7 @@ int fdpm_init(struct fdpm_privdata *priv)
 	int                    ret_val;
 	struct fdpm_drvdata    *pdrv = priv->pdrv;
 	struct platform_device *pdev = pdrv->pdev;
+	struct platform_device *pdev_c2 = pdrv->pdev_c2;
 	int                    ercd;
 	long                   sub_ercd;
 
@@ -155,8 +156,12 @@ int fdpm_init(struct fdpm_privdata *priv)
 	pm_runtime_enable(&pdev->dev);
 	pm_runtime_get_sync(&pdev->dev);
 
+	pm_suspend_ignore_children(&pdev_c2->dev, true);
+	pm_runtime_enable(&pdev_c2->dev);
+	pm_runtime_get_sync(&pdev_c2->dev);
+
 	/* enable clock */
-	pdrv->fdpm_clk[0] = clk_get(NULL, "fdp0");
+	pdrv->fdpm_clk[0] = clk_get(NULL, "fdp1-0");
 	if (IS_ERR(pdrv->fdpm_clk[0])) {
 		APRINT("failed to get FDP0 clock\n");
 		ercd = -EFAULT;
@@ -170,7 +175,7 @@ int fdpm_init(struct fdpm_privdata *priv)
 	}
 
 #if defined(M2CONFIG) || defined(H2CONFIG)
-	pdrv->fdpm_clk[1] = clk_get(NULL, "fdp1");
+	pdrv->fdpm_clk[1] = clk_get(NULL, "fdp1-1");
 	if (IS_ERR(pdrv->fdpm_clk[1])) {
 		APRINT("failed to get FDP1 clock\n");
 		ercd = -EFAULT;
@@ -185,7 +190,7 @@ int fdpm_init(struct fdpm_privdata *priv)
 #endif
 
 #if defined(H2CONFIG)
-	pdrv->fdpm_clk[2] = clk_get(NULL, "fdp2");
+	pdrv->fdpm_clk[2] = clk_get(NULL, "fdp1-2");
 	if (IS_ERR(pdrv->fdpm_clk[2])) {
 		APRINT("failed to get FDP2 clock\n");
 		ercd = -EFAULT;
@@ -207,6 +212,14 @@ int fdpm_init(struct fdpm_privdata *priv)
 		goto exit;
 	}
 
+	ret_val = fdpm_lib_driver_initialize(pdev_c2, priv, &sub_ercd);
+	if (ret_val != 0) {
+		APRINT("failed to fdpm_lib_driver_initialize %d (%ld)\n",
+		       ret_val, sub_ercd);
+		ret = -EFAULT;
+		goto exit;
+	}
+
 	DPRINT("done\n");
 	return 0;
 
@@ -235,14 +248,15 @@ int fdpm_lib_driver_initialize(struct platform_device *pdev,
 	int ercd;
 	int i;
 	int ret;
+	static int channel = 0;
 
 	if ((pdev == NULL) || (priv == NULL)) {
 		ret = -EINVAL;
 		goto exit;
 	}
 
-	for (i = 0; i < FDPM_FDP_NUM; i++) {
-		ercd = fdp_ins_allocate_memory(&priv->FDP_obj[i]);
+	for (i = 0; i < FDPM_FDP_NUM - 1; i++) {
+		ercd = fdp_ins_allocate_memory(&priv->FDP_obj[channel]);
 		if (ercd) {
 			if (sub_ercd != NULL)
 				*sub_ercd = ercd;
@@ -251,14 +265,14 @@ int fdpm_lib_driver_initialize(struct platform_device *pdev,
 		}
 
 		/* initialize register */
-		ercd = fdp_ins_init_reg(pdev, i, priv->FDP_obj[i]);
+		ercd = fdp_ins_init_reg(pdev, i, priv->FDP_obj[channel]);
 		if (ercd) {
 			if (sub_ercd != NULL)
 				*sub_ercd = ercd;
 			ret = -EIO;
 			goto exit;
 		}
-		ercd = drv_FDP_Init(priv->FDP_obj[i]);
+		ercd = drv_FDP_Init(priv->FDP_obj[channel]);
 		if (ercd) {
 			if (sub_ercd != NULL)
 				*sub_ercd = ercd;
@@ -266,7 +280,7 @@ int fdpm_lib_driver_initialize(struct platform_device *pdev,
 			goto exit;
 		}
 		/* registory interrupt handler */
-		ercd = fdp_reg_inth(pdev, i, priv->FDP_obj[i]);
+		ercd = fdp_reg_inth(pdev, i, priv->FDP_obj[channel]);
 		if (ercd) {
 			if (sub_ercd != NULL)
 				*sub_ercd = ercd;
@@ -275,8 +289,8 @@ int fdpm_lib_driver_initialize(struct platform_device *pdev,
 		}
 	}
 
-	for (i = 0; i < FDPM_FDP_NUM; i++) {
-		ercd = drv_FDP_Open(priv->FDP_obj[i], sub_ercd);
+	for (i = 0; i < FDPM_FDP_NUM - 1; i++) {
+		ercd = drv_FDP_Open(priv->FDP_obj[channel], sub_ercd);
 		if (ercd) {
 			if (sub_ercd != NULL)
 				*sub_ercd = ercd;
@@ -284,7 +298,9 @@ int fdpm_lib_driver_initialize(struct platform_device *pdev,
 			goto exit;
 		}
 	}
-	fdpm_thread(priv);
+	if (channel == 1)
+		fdpm_thread(priv);
+	channel++;
 
 	NPRINT("%s\n", __func__);
 	ret = R_FDPM_OK;
@@ -315,6 +331,7 @@ int fdpm_quit(struct fdpm_privdata *priv)
 	int ret;
 	struct fdpm_drvdata    *pdrv = priv->pdrv;
 	struct platform_device *pdev = pdrv->pdev;
+	struct platform_device *pdev_c2 = pdrv->pdev_c2;
 	long                   wret;
 
 	DPRINT("called\n");
@@ -343,6 +360,9 @@ int fdpm_quit(struct fdpm_privdata *priv)
 	pm_runtime_put_sync(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
 
+	pm_runtime_put_sync(&pdev_c2->dev);
+	pm_runtime_disable(&pdev_c2->dev);
+
 	DPRINT("done\n");
 	return 0;
 exit:
@@ -357,6 +377,7 @@ int fdpm_lib_driver_quit(struct fdpm_privdata *priv)
 	int i;
 	struct fdpm_drvdata    *pdrv = priv->pdrv;
 	struct platform_device *pdev = pdrv->pdev;
+	struct platform_device *pdev_c2 = pdrv->pdev_c2;
 
 	if (priv == NULL) {
 		ret = 0;
@@ -373,8 +394,6 @@ int fdpm_lib_driver_quit(struct fdpm_privdata *priv)
 		complete(&priv->post_thread[i].start2);
 		kthread_stop(priv->post_thread[i].th);
 
-		fdpm_free_inth(pdev, i, priv->FDP_obj[i]);
-
 		ercd = drv_FDP_Quit(priv->FDP_obj[i]);
 		if (ercd) {
 			DPRINT("drv_FDP_Quit fail %d\n", ercd);
@@ -396,6 +415,9 @@ int fdpm_lib_driver_quit(struct fdpm_privdata *priv)
 		}
 		priv->FDP_obj[i] = NULL;
 	}
+
+	fdpm_free_inth(pdev, 0, priv->FDP_obj[0]);
+	fdpm_free_inth(pdev_c2, 0, priv->FDP_obj[1]);
 	sub_ercd = ercd;
 
 	DPRINT("done\n");
diff --git a/drv/include/fdpm_main.h b/drv/include/fdpm_main.h
index 213e1f5..3c5a134 100755
--- a/drv/include/fdpm_main.h
+++ b/drv/include/fdpm_main.h
@@ -121,6 +121,7 @@ typedef struct {
 
 struct fdpm_drvdata {
 	struct platform_device *pdev;
+	struct platform_device *pdev_c2;
 	struct class *pcls;
 	struct cdev cdev;
 	struct task_struct *task;
-- 
1.9.1

