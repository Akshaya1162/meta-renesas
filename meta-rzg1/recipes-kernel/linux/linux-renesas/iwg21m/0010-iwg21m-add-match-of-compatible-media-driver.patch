commit a31ec43c2e394a058147b0182737ad79141ee37e
Author: khoahvd <khoahvd@fsoft.com.vn>
Date:   Thu Nov 24 14:59:59 2016 +0700

    Add match of compatible r8a7742-iwg21m_q7 for media driver

diff --git a/drivers/media/i2c/soc_camera/Kconfig b/drivers/media/i2c/soc_camera/Kconfig
index 23d352f..c9db3fa 100644
--- a/drivers/media/i2c/soc_camera/Kconfig
+++ b/drivers/media/i2c/soc_camera/Kconfig
@@ -44,6 +44,12 @@ config SOC_CAMERA_OV2640
 	help
 	  This is a ov2640 camera driver
 
+config SOC_CAMERA_OV5640
+	tristate "ov5640 camera support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a V4L2 camera driver for the OmniVision OV5640 sensor
+
 config SOC_CAMERA_OV5642
 	tristate "ov5642 camera support"
 	depends on SOC_CAMERA && I2C
@@ -62,6 +68,12 @@ config SOC_CAMERA_OV772X
 	help
 	  This is a ov772x camera driver
 
+config SOC_CAMERA_OV7725
+	tristate "ov7725 camera support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a ov7725 camera driver
+
 config SOC_CAMERA_OV9640
 	tristate "ov9640 camera support"
 	depends on SOC_CAMERA && I2C
diff --git a/drivers/media/i2c/soc_camera/Makefile b/drivers/media/i2c/soc_camera/Makefile
index d0421fe..5dbb8db 100644
--- a/drivers/media/i2c/soc_camera/Makefile
+++ b/drivers/media/i2c/soc_camera/Makefile
@@ -5,9 +5,11 @@ obj-$(CONFIG_SOC_CAMERA_MT9T031)	+= mt9t031.o
 obj-$(CONFIG_SOC_CAMERA_MT9T112)	+= mt9t112.o
 obj-$(CONFIG_SOC_CAMERA_MT9V022)	+= mt9v022.o
 obj-$(CONFIG_SOC_CAMERA_OV2640)		+= ov2640.o
+obj-$(CONFIG_SOC_CAMERA_OV5640)		+= ov5640.o
 obj-$(CONFIG_SOC_CAMERA_OV5642)		+= ov5642.o
 obj-$(CONFIG_SOC_CAMERA_OV6650)		+= ov6650.o
 obj-$(CONFIG_SOC_CAMERA_OV772X)		+= ov772x.o
+obj-$(CONFIG_SOC_CAMERA_OV7725)		+= ov7725.o
 obj-$(CONFIG_SOC_CAMERA_OV9640)		+= ov9640.o
 obj-$(CONFIG_SOC_CAMERA_OV9740)		+= ov9740.o
 obj-$(CONFIG_SOC_CAMERA_RJ54N1)		+= rj54n1cb0c.o
diff --git a/drivers/media/i2c/soc_camera/ov5640.c b/drivers/media/i2c/soc_camera/ov5640.c
new file mode 100644
index 0000000..6b1bcf1
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/ov5640.c
@@ -0,0 +1,978 @@
+/*
+ * Copyright (c) 2015 iWave Systems Technologies Pvt. Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/module.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-subdev.h>
+#include <media/soc_camera.h>
+#include <media/soc_mediabus.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+
+
+/*
+ * window size list
+ */
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define VGA_WIDTH	640
+#define VGA_HEIGHT	480
+#define HD_WIDTH	1280
+#define HD_HEIGHT	720
+#define FHD_WIDTH	1920
+#define FHD_HEIGHT	1080
+#define MAX_WIDTH   	HD_WIDTH
+#define MAX_HEIGHT  	HD_HEIGHT
+
+/*
+ * ID
+ */
+#define OV5640  0x5640
+#define VERSION(pid, ver) ((pid<<8)|(ver&0xFF))
+
+static int debug;
+module_param(debug, int, 0);
+MODULE_PARM_DESC(debug, "Debug level (0-2)");
+
+
+/*
+ * struct
+ */
+struct regval_list {
+	u16 reg_num;
+	unsigned char value;
+};
+
+struct ov5640_color_format {
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+};
+
+static const struct v4l2_frmsize_discrete ov5640_frmsizes[] = {
+	{QVGA_WIDTH, QVGA_HEIGHT},
+	{VGA_WIDTH, VGA_HEIGHT},
+	{HD_WIDTH, HD_HEIGHT},
+	{FHD_WIDTH, FHD_HEIGHT},
+};
+
+struct ov5640_win_size {
+	char                     *name;
+	__u32                     width;
+	__u32                     height;
+	const struct regval_list *regs;
+};
+
+struct ov5640 {
+	struct v4l2_subdev                sd;
+	const struct ov5640_color_format *cfmt;
+	const struct ov5640_win_size     *win;
+	int                               model;
+	unsigned short                    vflip:1;
+	unsigned short                    hflip:1;
+	/* band_filter = COM8[5] ? 256 - BDBASE : 0 */
+	unsigned short                    band_filter;
+};
+
+#define ENDMARKER { 0xff, 0xff }
+
+/*
+ * register setting for window size
+ */
+static const struct regval_list ov5640_qvga_regs[] = {
+	{0x3008, 0x82},
+	{0x4730, 0x01},
+	{0x3103, 0x03}, {0x3017, 0xff}, {0x3018, 0xff},
+	{0x3034, 0x1a}, {0x3037, 0x13}, {0x3108, 0x01},
+	{0x3630, 0x36}, {0x3631, 0x0e}, {0x3632, 0xe2},
+	{0x3633, 0x12}, {0x3621, 0xe0}, {0x3704, 0xa0},
+	{0x3703, 0x5a}, {0x3715, 0x78}, {0x3717, 0x01},
+	{0x370b, 0x60}, {0x3705, 0x1a}, {0x3905, 0x02},
+	{0x3906, 0x10}, {0x3901, 0x0a}, {0x3731, 0x12},
+	{0x3600, 0x08}, {0x3601, 0x33}, {0x302d, 0x60},
+	{0x3620, 0x52}, {0x371b, 0x20}, {0x471c, 0x50},
+	{0x3a13, 0x43}, {0x3a18, 0x00}, {0x3a19, 0x7c},
+	{0x3635, 0x13}, {0x3636, 0x03}, {0x3634, 0x40},
+	{0x3622, 0x01}, {0x3c01, 0x34}, {0x3c04, 0x28},
+	{0x3c05, 0x98}, {0x3c06, 0x00}, {0x3c07, 0x08},
+	{0x3c08, 0x00}, {0x3c09, 0x1c}, {0x3c0a, 0x9c},
+	{0x3c0b, 0x40}, {0x3810, 0x00}, {0x3811, 0x10},
+	{0x3812, 0x00}, {0x3708, 0x64}, {0x4001, 0x02},
+	{0x4005, 0x1a}, {0x3000, 0x00}, {0x3004, 0xff},
+	{0x300e, 0x58}, //Bit[2]:mipi_en 0:DVP enable 1:MIPI enable
+	{0x302e, 0x00}, {0x4300, 0x32},
+	{0x501f, 0x00}, //ISP format control registers - 000: ISP YUV422
+	{0x440e, 0x00}, {0x5000, 0xa7},
+	{0x3008, 0x02},
+	{0x4730, 0x01},
+
+	{0x3c07, 0x08}, {0x3820, 0x41}, {0x3821, 0x07},
+	{0x3814, 0x31}, {0x3815, 0x31}, {0x3800, 0x00},
+	{0x3801, 0x00}, {0x3802, 0x00}, {0x3803, 0x04},
+	{0x3804, 0x0a}, {0x3805, 0x3f}, {0x3806, 0x07},
+	{0x3807, 0x9b}, {0x3808, 0x01}, {0x3809, 0x40},
+	{0x380a, 0x00}, {0x380b, 0xf0}, {0x380c, 0x07},
+	{0x380d, 0x68}, {0x380e, 0x03}, {0x380f, 0xd8},
+	{0x3813, 0x06}, {0x3618, 0x00}, {0x3612, 0x29},
+	{0x3709, 0x52}, {0x370c, 0x03}, {0x3a02, 0x0b},
+	{0x3a03, 0x88}, {0x3a14, 0x0b}, {0x3a15, 0x88},
+	{0x4004, 0x02}, {0x3002, 0x1c}, {0x3006, 0xc3},
+	{0x4713, 0x03}, {0x4407, 0x04}, {0x460b, 0x35},
+	{0x460c, 0x22}, {0x4837, 0x22}, {0x3824, 0x02},
+	{0x5001, 0xa3}, {0x3034, 0x1a}, {0x3035, 0x11},
+	{0x3036, 0x46}, {0x3037, 0x13},
+
+	ENDMARKER,
+};
+
+//ov5640_setting_30fps_VGA_640x480
+static const struct regval_list ov5640_vga_regs[] = {
+	{0x3103,0x11}, {0x3008,0x82}, {0x4730,0x01},
+	{0x3008,0x42}, {0x4730,0x01}, {0x3103,0x03},
+	{0x3017,0xff}, {0x3018,0xff}, {0x3034,0x1a},
+	{0x3037,0x13}, {0x3108,0x01}, {0x3630,0x36},
+	{0x3631,0x0e}, {0x3632,0xe2}, {0x3633,0x12},
+	{0x3621,0xe0}, {0x3704,0xa0}, {0x3703,0x5a},
+	{0x3715,0x78}, {0x3717,0x01}, {0x370b,0x60},
+	{0x3705,0x1a}, {0x3905,0x02}, {0x3906,0x10},
+	{0x3901,0x0a}, {0x3731,0x12}, {0x3600,0x08},
+	{0x3601,0x33}, {0x302d,0x60}, {0x3620,0x52},
+	{0x371b,0x20}, {0x471c,0x50}, {0x3a13,0x43},
+	{0x3a18,0x00}, {0x3a19,0x7c}, {0x3635,0x13},
+	{0x3636,0x03}, {0x3634,0x40}, {0x3622,0x01},
+	{0x3c01,0x34}, {0x3c04,0x28}, {0x3c05,0x98},
+	{0x3c06,0x00}, {0x3c07,0x07}, {0x3c08,0x00},
+	{0x3c09,0x1c}, {0x3c0a,0x9c}, {0x3c0b,0x40},
+	{0x3810,0x00}, {0x3811,0x10}, {0x3812,0x00},
+	{0x3708,0x64}, {0x4001,0x02}, {0x4005,0x1a},
+	{0x3000,0x00}, {0x3004,0xff}, {0x300e,0x58},
+	{0x302e,0x00}, {0x4300,0x32}, {0x501f,0x00},
+	{0x440e,0x00}, {0x5000,0xa7},
+	{0x3008,0x02},
+	{0x4730,0x01},
+	{0x3008,0x42},
+	{0x4730,0x01},
+	{0x3103,0x03}, {0x3017,0xff}, {0x3018,0xff},
+	{0x3034,0x1a}, {0x3035,0x11}, {0x3036,0x46},
+	{0x3037,0x13}, {0x3108,0x01}, {0x3630,0x36},
+	{0x3631,0x0e}, {0x3632,0xe2}, {0x3633,0x12},
+	{0x3621,0xe0}, {0x3704,0xa0}, {0x3703,0x5a},
+	{0x3715,0x78}, {0x3717,0x01}, {0x370b,0x60},
+	{0x3705,0x1a}, {0x3905,0x02}, {0x3906,0x10},
+	{0x3901,0x0a}, {0x3731,0x12}, {0x3600,0x08},
+	{0x3601,0x33}, {0x302d,0x60}, {0x3620,0x52},
+	{0x371b,0x20}, {0x471c,0x50}, {0x3a13,0x43},
+	{0x3a18,0x00}, {0x3a19,0xf8}, {0x3635,0x13},
+	{0x3636,0x03}, {0x3634,0x40}, {0x3622,0x01},
+	{0x3c01,0x34}, {0x3c04,0x28}, {0x3c05,0x98},
+	{0x3c06,0x00}, {0x3c07,0x08}, {0x3c08,0x00},
+	{0x3c09,0x1c}, {0x3c0a,0x9c}, {0x3c0b,0x40},
+	{0x3820,0x41}, {0x3821,0x07}, {0x3814,0x31},
+	{0x3815,0x31}, {0x3800,0x00}, {0x3801,0x00},
+	{0x3802,0x00}, {0x3803,0x04}, {0x3804,0x0a},
+	{0x3805,0x3f}, {0x3806,0x07}, {0x3807,0x9b},
+	{0x3808,0x02}, {0x3809,0x80}, {0x380a,0x01},
+	{0x380b,0xe0}, {0x380c,0x07}, {0x380d,0x68},
+	{0x380e,0x03}, {0x380f,0xd8}, {0x3810,0x00},
+	{0x3811,0x10}, {0x3812,0x00}, {0x3813,0x06},
+	{0x3618,0x00}, {0x3612,0x29}, {0x3708,0x64},
+	{0x3709,0x52}, {0x370c,0x03}, {0x3a02,0x03},
+	{0x3a03,0xd8}, {0x3a08,0x01}, {0x3a09,0x27},
+	{0x3a0a,0x00}, {0x3a0b,0xf6}, {0x3a0e,0x03},
+	{0x3a0d,0x04}, {0x3a14,0x03}, {0x3a15,0xd8},
+	{0x4001,0x02}, {0x4004,0x02}, {0x3000,0x00},
+	{0x3002,0x1c}, {0x3004,0xff}, {0x3006,0xc3},
+	{0x300e,0x58}, {0x302e,0x00}, {0x4300,0x32},
+	{0x501f,0x00}, {0x4713,0x03}, {0x4407,0x04},
+	{0x440e,0x00}, {0x460b,0x35}, {0x460c,0x22},
+	{0x4837,0x22}, {0x3824,0x02}, {0x5000,0xa7},
+	{0x5001,0xa3}, {0x5180,0xff}, {0x5181,0xf2},
+	{0x5182,0x00}, {0x5183,0x14}, {0x5184,0x25},
+	{0x5185,0x24}, {0x5186,0x09}, {0x5187,0x09},
+	{0x5188,0x09}, {0x5189,0x88}, {0x518a,0x54},
+	{0x518b,0xee}, {0x518c,0xb2}, {0x518d,0x50},
+	{0x518e,0x34}, {0x518f,0x6b}, {0x5190,0x46},
+	{0x5191,0xf8}, {0x5192,0x04}, {0x5193,0x70},
+	{0x5194,0xf0}, {0x5195,0xf0}, {0x5196,0x03},
+	{0x5197,0x01}, {0x5198,0x04}, {0x5199,0x6c},
+	{0x519a,0x04}, {0x519b,0x00}, {0x519c,0x09},
+	{0x519d,0x2b}, {0x519e,0x38}, {0x5381,0x1e},
+	{0x5382,0x5b}, {0x5383,0x08}, {0x5384,0x0a},
+	{0x5385,0x7e}, {0x5386,0x88}, {0x5387,0x7c},
+	{0x5388,0x6c}, {0x5389,0x10}, {0x538a,0x01},
+	{0x538b,0x98}, {0x5300,0x08}, {0x5301,0x30},
+	{0x5302,0x10}, {0x5303,0x00}, {0x5304,0x08},
+	{0x5305,0x30}, {0x5306,0x08}, {0x5307,0x16},
+	{0x5309,0x08}, {0x530a,0x30}, {0x530b,0x04},
+	{0x530c,0x06}, {0x5480,0x01}, {0x5481,0x08},
+	{0x5482,0x14}, {0x5483,0x28}, {0x5484,0x51},
+	{0x5485,0x65}, {0x5486,0x71}, {0x5487,0x7d},
+	{0x5488,0x87}, {0x5489,0x91}, {0x548a,0x9a},
+	{0x548b,0xaa}, {0x548c,0xb8}, {0x548d,0xcd},
+	{0x548e,0xdd}, {0x548f,0xea}, {0x5490,0x1d},
+	{0x5580,0x02}, {0x5583,0x40}, {0x5584,0x10},
+	{0x5589,0x10}, {0x558a,0x00}, {0x558b,0xf8},
+	{0x5800,0x23}, {0x5801,0x14}, {0x5802,0x0f},
+	{0x5803,0x0f}, {0x5804,0x12}, {0x5805,0x26},
+	{0x5806,0x0c}, {0x5807,0x08}, {0x5808,0x05},
+	{0x5809,0x05}, {0x580a,0x08}, {0x580b,0x0d},
+	{0x580c,0x08}, {0x580d,0x03}, {0x580e,0x00},
+	{0x580f,0x00}, {0x5810,0x03}, {0x5811,0x09},
+	{0x5812,0x07}, {0x5813,0x03}, {0x5814,0x00},
+	{0x5815,0x01}, {0x5816,0x03}, {0x5817,0x08},
+	{0x5818,0x0d}, {0x5819,0x08}, {0x581a,0x05},
+	{0x581b,0x06}, {0x581c,0x08}, {0x581d,0x0e},
+	{0x581e,0x29}, {0x581f,0x17}, {0x5820,0x11},
+	{0x5821,0x11}, {0x5822,0x15}, {0x5823,0x28},
+	{0x5824,0x46}, {0x5825,0x26}, {0x5826,0x08},
+	{0x5827,0x26}, {0x5828,0x64}, {0x5829,0x26},
+	{0x582a,0x24}, {0x582b,0x22}, {0x582c,0x24},
+	{0x582d,0x24}, {0x582e,0x06}, {0x582f,0x22},
+	{0x5830,0x40}, {0x5831,0x42}, {0x5832,0x24},
+	{0x5833,0x26}, {0x5834,0x24}, {0x5835,0x22},
+	{0x5836,0x22}, {0x5837,0x26}, {0x5838,0x44},
+	{0x5839,0x24}, {0x583a,0x26}, {0x583b,0x28},
+	{0x583c,0x42}, {0x583d,0xce}, {0x5025,0x00},
+	{0x3a0f,0x30}, {0x3a10,0x28}, {0x3a1b,0x30},
+	{0x3a1e,0x26}, {0x3a11,0x60}, {0x3a1f,0x14},
+	{0x3008,0x02},
+	{0x4730,0x01},
+	{0x3034,0x1a}, {0x3035,0x11}, {0x3036,0x46},
+	{0x3037,0x13},
+
+	ENDMARKER,
+};
+
+//ov5640_setting_30fps_720P_1280x720
+static const struct regval_list ov5640_1280_720_regs[] = {
+	{0x3008, 0x82},
+	{0x4730, 0x01},
+	{0x3103, 0x03}, {0x3017, 0xff}, {0x3018, 0xff},
+	{0x3034, 0x1a}, {0x3037, 0x13}, {0x3108, 0x01},
+	{0x3630, 0x36}, {0x3631, 0x0e}, {0x3632, 0xe2},
+	{0x3633, 0x12}, {0x3621, 0xe0}, {0x3704, 0xa0},
+	{0x3703, 0x5a}, {0x3715, 0x78}, {0x3717, 0x01},
+	{0x370b, 0x60}, {0x3705, 0x1a}, {0x3905, 0x02},
+	{0x3906, 0x10}, {0x3901, 0x0a}, {0x3731, 0x12},
+	{0x3600, 0x08}, {0x3601, 0x33}, {0x302d, 0x60},
+	{0x3620, 0x52}, {0x371b, 0x20}, {0x471c, 0x50},
+	{0x3a13, 0x43}, {0x3a18, 0x00}, {0x3a19, 0x7c},
+	{0x3635, 0x13}, {0x3636, 0x03}, {0x3634, 0x40},
+	{0x3622, 0x01}, {0x3c01, 0x34}, {0x3c04, 0x28},
+	{0x3c05, 0x98}, {0x3c06, 0x00}, {0x3c07, 0x08},
+	{0x3c08, 0x00}, {0x3c09, 0x1c}, {0x3c0a, 0x9c},
+	{0x3c0b, 0x40}, {0x3810, 0x00}, {0x3811, 0x10},
+	{0x3812, 0x00}, {0x3708, 0x64}, {0x4001, 0x02},
+	{0x4005, 0x1a}, {0x3000, 0x00}, {0x3004, 0xff},
+	{0x300e, 0x58}, //Bit[2]:mipi_en 0:DVP enable 1:MIPI enable
+	{0x302e, 0x00}, {0x4300, 0x32},
+	{0x501f, 0x00}, //ISP format control registers - 000: ISP YUV422
+	{0x440e, 0x00}, {0x5000, 0xa7},
+	{0x3008, 0x02},
+	{0x4730, 0x01},
+
+	{0x3035, 0x21}, //0x11:60fps 0x21:30fps 0x41:15fps 0xa1:7.5fps
+	{0x3036, 0x69}, {0x3c07, 0x07}, {0x3820, 0x41},
+	{0x3821, 0x07}, //light meter 1 thereshold
+	{0x3814, 0x31}, //horizton subsample
+	{0x3815, 0x31}, //vertical subsample
+	{0x3800, 0x00}, //x address start high byte
+	{0x3801, 0x00}, //x address start low byte
+	{0x3802, 0x00}, //y address start high byte
+	{0x3803, 0xfa}, //y address start low byte
+	{0x3804, 0x0a}, //x address end high byte
+	{0x3805, 0x3f}, //x address end low byte
+	{0x3806, 0x06}, //y address end high byte
+	{0x3807, 0xa9}, //y address end low byte
+	{0x3808, 0x05}, //H size MSB
+	{0x3809, 0x00}, //H size LSB
+	{0x380a, 0x02}, //V size MSB
+	{0x380b, 0xd0}, //V size LSB
+	{0x380c, 0x07}, //HTS MSB
+	{0x380d, 0x64}, //HTS LSB
+	{0x380e, 0x02}, //VTS MSB
+	{0x380f, 0xe4}, //VTS LSB
+	{0x3813, 0x04}, {0x3618, 0x00}, {0x3612, 0x29},
+	{0x3709, 0x52}, {0x370c, 0x03},
+	{0x3a02, 0x02}, //60HZ max exposure limit MSB
+	{0x3a03, 0xe0}, //60HZ max exposure limit LSB
+	{0x3a14, 0x02}, //50HZ max exposure limit MSB
+	{0x3a15, 0xe0}, //50HZ max exposure limit LSB
+	{0x4004, 0x02}, //BLC line number
+	{0x3002, 0x1c}, //reset JFIFO SFIFO JPG
+	{0x3006, 0xc3}, //enable xx clock
+	{0x4713, 0x03}, {0x4407, 0x04}, {0x3824, 0x01},
+	{0x460b, 0x37}, //debug mode
+	{0x460c, 0x20}, //PCLK manual enable
+	{0x4837, 0x16}, //PCLK period
+	{0x5001, 0xa3}, //ISP effect
+	{0x3503, 0x00}, //AEC enable
+	{0x3034, 0x1a}, //MIPI bit mode - 0x8: 8-bit mode 0xA: 10-bit mode
+	{0x3a08, 0x01}, //AEC B50 STEP - 50Hz Band Width
+	{0x3a0a, 0x01}, //AEC B60 STEP - 60Hz Band Width
+	{0x3a0d, 0x02}, //60Hz Max Bands in One Frame
+	{0x3037, 0x13},
+	{0x302c, 0x42},//bit[7:6]: output drive capability
+	//00: 1x   01: 2x  10: 3x  11: 4x
+	ENDMARKER,
+};
+
+//ov5640_setting_30fps_1080P_1920x1080
+static const struct regval_list ov5640_1920_1080_regs[] = {
+	{0x3008, 0x82},
+	{0x4730, 0x01},
+	{0x3103, 0x03}, {0x3017, 0xff}, {0x3018, 0xff},
+	{0x3034, 0x1a}, {0x3037, 0x13}, {0x3108, 0x01},
+	{0x3630, 0x36}, {0x3631, 0x0e}, {0x3632, 0xe2},
+	{0x3633, 0x12}, {0x3621, 0xe0}, {0x3704, 0xa0},
+	{0x3703, 0x5a}, {0x3715, 0x78}, {0x3717, 0x01},
+	{0x370b, 0x60}, {0x3705, 0x1a}, {0x3905, 0x02},
+	{0x3906, 0x10}, {0x3901, 0x0a}, {0x3731, 0x12},
+	{0x3600, 0x08}, {0x3601, 0x33}, {0x302d, 0x60},
+	{0x3620, 0x52}, {0x371b, 0x20}, {0x471c, 0x50},
+	{0x3a13, 0x43}, {0x3a18, 0x00}, {0x3a19, 0x7c},
+	{0x3635, 0x13}, {0x3636, 0x03}, {0x3634, 0x40},
+	{0x3622, 0x01}, {0x3c01, 0x34}, {0x3c04, 0x28},
+	{0x3c05, 0x98}, {0x3c06, 0x00}, {0x3c07, 0x08},
+	{0x3c08, 0x00}, {0x3c09, 0x1c}, {0x3c0a, 0x9c},
+	{0x3c0b, 0x40}, {0x3810, 0x00}, {0x3811, 0x10},
+	{0x3812, 0x00}, {0x3708, 0x64}, {0x4001, 0x02},
+	{0x4005, 0x1a}, {0x3000, 0x00}, {0x3004, 0xff},
+	{0x300e, 0x58}, //Bit[2]:mipi_en 0:DVP enable 1:MIPI enable
+	{0x302e, 0x00}, {0x4300, 0x32},
+	{0x501f, 0x00}, //ISP format control registers - 000: ISP YUV422
+	{0x440e, 0x00}, {0x5000, 0xa7}, {0x3008, 0x02},
+	{0x4730, 0x01},
+
+	{0x3c07, 0x07}, {0x3820, 0x40}, {0x3821, 0x06},
+	{0x3814, 0x11}, {0x3815, 0x11}, {0x3800, 0x00},
+	{0x3801, 0x00}, {0x3802, 0x00}, {0x3803, 0xee},
+	{0x3804, 0x0a}, {0x3805, 0x3f}, {0x3806, 0x05},
+	{0x3807, 0xc3}, {0x3808, 0x07}, {0x3809, 0x80},
+	{0x380a, 0x04}, {0x380b, 0x38}, {0x380c, 0x0b},
+	{0x380d, 0x1c}, {0x380e, 0x07}, {0x380f, 0xb0},
+	{0x3813, 0x04}, {0x3618, 0x04}, {0x3612, 0x2b},
+	{0x3709, 0x12}, {0x370c, 0x00}, {0x3a02, 0x07},
+	{0x3a03, 0xae}, {0x3a14, 0x07}, {0x3a15, 0xae},
+	{0x4004, 0x06}, {0x3002, 0x1c}, {0x3006, 0xc3},
+	{0x4713, 0x02}, {0x4407, 0x0c}, {0x460b, 0x37},
+	{0x460c, 0x20}, {0x4837, 0x2c}, {0x3824, 0x01},
+	{0x5001, 0x87}, {0x3034, 0x1a}, {0x3035, 0x21},
+	{0x3036, 0x69}, {0x3037, 0x13},
+
+	ENDMARKER,
+};
+
+/*
+ * supported color format list
+ */
+static const struct ov5640_color_format ov5640_cfmts[] = {
+	{
+		.code		= V4L2_MBUS_FMT_YUYV8_2X8,
+		.colorspace	= V4L2_COLORSPACE_JPEG,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_YVYU8_2X8,
+		.colorspace	= V4L2_COLORSPACE_JPEG,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_UYVY8_2X8,
+		.colorspace	= V4L2_COLORSPACE_JPEG,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_RGB555_2X8_PADHI_BE,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_RGB565_2X8_LE,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_RGB565_2X8_BE,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+	},
+};
+
+
+static const struct ov5640_win_size ov5640_win_qvga_size_regs = {
+	.name     = "QVGA",
+	.width    = QVGA_WIDTH,
+	.height   = QVGA_HEIGHT,
+	.regs     = ov5640_qvga_regs,
+};
+static const struct ov5640_win_size ov5640_win_vga_size_regs = {
+	.name     = "VGA",
+	.width    = VGA_WIDTH,
+	.height   = VGA_HEIGHT,
+	.regs     = ov5640_vga_regs,
+};
+static const struct ov5640_win_size ov5640_win_hd_size_regs = {
+	.name     = "HD",
+	.width    = HD_WIDTH,
+	.height   = HD_HEIGHT,
+	.regs     = ov5640_1280_720_regs,
+};
+static const struct ov5640_win_size ov5640_win_fhd_size_regs = {
+	.name     = "FHD",
+	.width    = FHD_WIDTH,
+	.height   = FHD_HEIGHT,
+	.regs     = ov5640_1920_1080_regs,
+};
+
+/*
+ * general function
+ */
+
+static struct ov5640_priv *to_ov5640(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ov5640, sd);
+}
+
+static int ov5640_read(struct v4l2_subdev *sd, u16 reg, u8 *val)
+{
+	int ret;
+	/* We have 16-bit i2c addresses - care for endianess */
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	unsigned char data[2] = { reg >> 8, reg & 0xff };
+
+	ret = i2c_master_send(c, data, 2);
+	if (ret < 2) {
+		dev_err(&c->dev, "%s: i2c read error, reg: %x\n",
+				__func__, reg);
+		return ret < 0 ? ret : -EIO;
+	}
+
+	ret = i2c_master_recv(c, val, 1);
+	if (ret < 1) {
+		dev_err(&c->dev, "%s: i2c read error, reg: %x\n",
+				__func__, reg);
+		return ret < 0 ? ret : -EIO;
+	}
+	return 0;
+}
+
+static inline int ov5640_write(struct v4l2_subdev *sd, u16 reg,
+		unsigned char val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	unsigned char data[3] = { reg >> 8, reg & 0xff, val };
+
+	ret = i2c_master_send(client, data, 3);
+	if (ret < 3) {
+		dev_err(&client->dev, "%s: i2c write error, reg: %x\n",
+				__func__, reg);
+		return ret < 0 ? ret : -EIO;
+	}
+
+	return 0;
+}
+
+static inline int ov5640_mask_set(struct v4l2_subdev *sd, unsigned char addr,
+		u8  mask, u8  set)
+{
+	return 0;
+}
+
+static int ov5640_write_array(struct v4l2_subdev *sd,
+		const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = ov5640_write(sd, vals->reg_num,
+				vals->value);
+		if (ret < 0)
+			return ret;
+		vals++;
+	}
+	return 0;
+}
+
+static int ov5640_reset(struct v4l2_subdev *sd, u32 val)
+{
+	if (ov5640_write (sd, 0x3008, 0x82))
+		return -1;
+
+	return 0;
+}
+
+/*
+ * soc_camera_ops function
+ */
+
+static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ov5640_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	return 0;
+}
+
+static int ov5640_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	return 0;
+}
+
+static int ov5640_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	return 0;
+}
+
+static int ov5640_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV5640, 0);
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov5640_g_register(struct v4l2_subdev *sd,
+		struct v4l2_dbg_register *reg)
+{
+	int ret;
+
+	reg->size = 1;
+	if (reg->reg > 0xffff)
+		return -EINVAL;
+
+	ov5640_read(sd, reg->reg, &ret);
+	if (ret < 0)
+		return ret;
+
+	reg->val = (__u64)ret;
+
+	return 0;
+}
+
+static int ov5640_s_register(struct v4l2_subdev *sd,
+		struct v4l2_dbg_register *reg)
+{
+
+	if (reg->reg > 0xffff ||
+			reg->val > 0xff)
+		return -EINVAL;
+
+	ov5640_write (sd, reg->reg, reg->val);
+
+	return 0;
+}
+#endif
+
+/* Find a frame size in an array */
+static int ov5640_find_framesize(u32 width, u32 height)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ov5640_frmsizes); i++) {
+		if ((ov5640_frmsizes[i].width >= width) &&
+				(ov5640_frmsizes[i].height >= height))
+			break;
+	}
+	/* If not found, select biggest */
+	if (i >= ARRAY_SIZE(ov5640_frmsizes))
+		i = ARRAY_SIZE(ov5640_frmsizes) - 1;
+
+	return i;
+}
+
+static const struct ov5640_win_size *ov5640_select_win(u32 width, u32 height)
+{
+	const struct ov5640_win_size *win;
+	int f_size = ov5640_find_framesize(width, height);
+
+	switch (ov5640_frmsizes[f_size].width) {
+		case QVGA_WIDTH:
+			win = &ov5640_win_qvga_size_regs;
+			break;
+		case VGA_WIDTH:
+			win = &ov5640_win_vga_size_regs;
+			break;
+		case HD_WIDTH:
+			win = &ov5640_win_hd_size_regs;
+			break;
+		case FHD_WIDTH:
+			win = &ov5640_win_fhd_size_regs;
+			break;
+	}
+
+	return win;
+}
+
+static int ov5640_set_params(struct v4l2_subdev *sd, u32 *width, u32 *height,
+		enum v4l2_mbus_pixelcode code)
+{
+	struct ov5640 *core = to_ov5640(sd);
+	int i;
+
+	/*
+	 * select format
+	 */
+	core->cfmt = NULL;
+	for (i = 0; i < ARRAY_SIZE(ov5640_cfmts); i++) {
+		if (code == ov5640_cfmts[i].code) {
+			core->cfmt = ov5640_cfmts + i;
+			break;
+		}
+	}
+	if (!core->cfmt)
+		goto ov5640_set_fmt_error;
+
+	/*
+	 * select win
+	 */
+	core->win = ov5640_select_win(*width, *height);
+
+
+	//reset hardware
+	ov5640_reset(sd, 0);
+
+	ov5640_write_array(sd, core->win->regs);
+
+	/*
+	 * set size format
+	 */
+	*width = core->win->width;
+	*height = core->win->height;
+
+	return 0;
+
+ov5640_set_fmt_error:
+
+	ov5640_reset(sd, 0);
+	core->win = NULL;
+	core->cfmt = NULL;
+
+	return 0;
+}
+
+static int ov5640_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)
+{
+	struct ov5640 *core = to_ov5640(sd);
+
+	a->c.left	= 0;
+	a->c.top	= 0;
+	a->c.width	= core->win->width;
+	a->c.height	= core->win->height;
+	a->type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	return 0;
+}
+
+static int ov5640_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)
+{
+	struct ov5640 *core = to_ov5640(sd);
+
+	a->bounds.left			= 0;
+	a->bounds.top			= 0;
+	a->bounds.width			= FHD_WIDTH;
+	a->bounds.height		= FHD_HEIGHT;
+	a->defrect			= a->bounds;
+	a->type				= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	a->pixelaspect.numerator	= 1;
+	a->pixelaspect.denominator	= 1;
+
+	return 0;
+}
+
+static int ov5640_g_fmt(struct v4l2_subdev *sd,
+		struct v4l2_mbus_framefmt *mf)
+{
+	struct ov5640 *core = to_ov5640(sd);
+
+	if (!core->win || !core->cfmt) {
+		int f_size = ov5640_find_framesize(mf->width, mf->height);
+		u32 width = ov5640_frmsizes[f_size].width, height = ov5640_frmsizes[f_size].height;
+		int ret = ov5640_set_params(sd, &width, &height,
+				V4L2_MBUS_FMT_YUYV8_2X8);
+		if (ret < 0)
+			return ret;
+	}
+
+	mf->width	= core->win->width;
+	mf->height	= core->win->height;
+	mf->code	= core->cfmt->code;
+	mf->colorspace	= core->cfmt->colorspace;
+	mf->field	= V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov5640_s_fmt(struct v4l2_subdev *sd,
+		struct v4l2_mbus_framefmt *mf)
+{
+	struct ov5640 *core = to_ov5640(sd);
+	int ret = ov5640_set_params(sd, &mf->width, &mf->height,
+			mf->code);
+
+	if (!ret)
+		mf->colorspace = core->cfmt->colorspace;
+
+	return ret;
+}
+
+static int ov5640_try_fmt(struct v4l2_subdev *sd,
+		struct v4l2_mbus_framefmt *mf)
+{
+	struct ov5640 *core = to_ov5640(sd);
+	const struct ov5640_win_size *win;
+	int i;
+
+	/*
+	 * select suitable win
+	 */
+	core->win = ov5640_select_win(mf->width, mf->height);
+
+	mf->width	= core->win->width;
+	mf->height	= core->win->height;
+	mf->field	= V4L2_FIELD_NONE;
+
+	for (i = 0; i < ARRAY_SIZE(ov5640_cfmts); i++)
+		if (mf->code == ov5640_cfmts[i].code)
+			break;
+
+	if (i == ARRAY_SIZE(ov5640_cfmts)) {
+		/* Unsupported format requested. Propose either */
+		if (core->cfmt) {
+			/* the current one or */
+			mf->colorspace = core->cfmt->colorspace;
+			mf->code = core->cfmt->code;
+		} else {
+			/* the default one */
+			mf->colorspace = ov5640_cfmts[0].colorspace;
+			mf->code = ov5640_cfmts[0].code;
+		}
+	} else {
+		/* Also return the colorspace */
+		mf->colorspace	= ov5640_cfmts[i].colorspace;
+	}
+
+	return 0;
+}
+
+static int ov5640_video_probe (struct v4l2_subdev *sd)
+{
+	u8 pid, ver;
+	const char         *devname;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640 *core = to_ov5640(sd);
+
+	/*
+	 * check and show product ID and manufacturer ID
+	 */
+	ov5640_read(sd, 0x300a, &pid);
+	ov5640_read(sd, 0x300b, &ver);
+	switch (VERSION(pid, ver)) {
+		case OV5640:
+			devname     = "ov5640";
+			core->model = V4L2_IDENT_OV5640;
+			break;
+		default:
+			dev_err(&client->dev, "Product ID error %x:%x\n", pid, ver);
+			return -ENODEV;
+	}
+
+	dev_info(&client->dev,
+			"%s: Product ID %0x:%0x\n",
+			devname,
+			pid,
+			ver);
+	return 0;
+
+}
+
+static struct v4l2_subdev_core_ops ov5640_subdev_core_ops = {
+	.reset		= ov5640_reset,
+	.queryctrl      = ov5640_queryctrl,
+	.g_ctrl		= ov5640_g_ctrl,
+	.s_ctrl		= ov5640_s_ctrl,
+	.g_chip_ident	= ov5640_g_chip_ident,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register	= ov5640_g_register,
+	.s_register	= ov5640_s_register,
+#endif
+};
+
+static int ov5640_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+		enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= ARRAY_SIZE(ov5640_cfmts))
+		return -EINVAL;
+
+	*code = ov5640_cfmts[index].code;
+
+	return 0;
+}
+
+static int ov5640_g_mbus_config(struct v4l2_subdev *sd,
+		struct v4l2_mbus_config *cfg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
+
+	cfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_MASTER |
+		V4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_HIGH |
+		V4L2_MBUS_DATA_ACTIVE_HIGH;
+	cfg->type = V4L2_MBUS_BT656;
+	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
+
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops ov5640_subdev_video_ops = {
+	.s_stream	= ov5640_s_stream,
+	.g_mbus_fmt	= ov5640_g_fmt,
+	.s_mbus_fmt	= ov5640_s_fmt,
+	.try_mbus_fmt	= ov5640_try_fmt,
+	.cropcap	= ov5640_cropcap,
+	.g_crop		= ov5640_g_crop,
+	.enum_mbus_fmt	= ov5640_enum_fmt,
+	.g_mbus_config  = ov5640_g_mbus_config,
+};
+
+static struct v4l2_subdev_ops ov5640_subdev_ops = {
+	.core	= &ov5640_subdev_core_ops,
+	.video	= &ov5640_subdev_video_ops,
+};
+
+/*
+ * i2c_driver function
+ */
+static int ov5640_probe(struct i2c_client *client,
+		const struct i2c_device_id *did)
+{
+	struct ov5640 *core;
+	struct v4l2_subdev *sd;
+	int ret;
+	u8 chip_id_high, chip_id_low;
+
+#ifdef CONFIG_MACH_IWG21M
+	struct device_node *np;
+	int cam0_pwr, cam2_pwr;
+	u32 status = -1;
+
+	np = of_find_compatible_node(NULL, NULL, "iwave,g21m-q7-com");
+	of_property_read_u32(np, "vin0-status", &status);
+	if(status) {
+		cam0_pwr = of_get_named_gpio(np, "cam0-pwr", 0);
+		if (gpio_is_valid(cam0_pwr) &&
+				!gpio_request_one(cam0_pwr, GPIOF_DIR_OUT, "cam0-pwr")) {
+			gpio_set_value(cam0_pwr, 1);
+			mdelay(100);
+			gpio_set_value(cam0_pwr, 0);
+		}
+	}
+	of_property_read_u32(np, "vin2-status", &status);
+	if(status) {
+		cam2_pwr = of_get_named_gpio(np, "cam2-pwr", 0);
+		if (gpio_is_valid(cam2_pwr) &&
+				!gpio_request_one(cam2_pwr, GPIOF_DIR_OUT, "cam2-pwr")) {
+			gpio_set_value(cam2_pwr, 1);
+			mdelay(100);
+			gpio_set_value(cam2_pwr, 0);
+		}
+	}
+#endif
+
+	/* Check if the adapter supports the needed features */
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+		return -EIO;
+
+	core = kzalloc(sizeof(struct ov5640), GFP_KERNEL);
+	if (!core) {
+		return -ENOMEM;
+	}
+	sd = &core->sd;
+	v4l2_i2c_subdev_init(sd, client, &ov5640_subdev_ops);
+
+	ret = ov5640_read(sd, 0x300a, &chip_id_high);
+	if (chip_id_high != 0x56) {
+		pr_warning("camera ov5640 is not found\n");
+		return -ENODEV;
+	}
+	ret = ov5640_read(sd, 0x300b, &chip_id_low);
+	if (chip_id_low != 0x40) {
+		pr_warning("camera ov5640 is not found\n");
+		return -ENODEV;
+	}
+
+	v4l_info(client, "chip found @ 0x%02x (%s)\n",
+			client->addr , client->adapter->name);
+	ret = ov5640_video_probe(sd);
+	if (ret) {
+		v4l2_info(sd, "camera ov5640 is not found.\n");
+		kfree(core);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int ov5640_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_dbg(1, debug, sd,
+			"ov5640.c: removing ov5640 adapter on address 0x%x\n",
+			client->addr << 1);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_ov5640(sd));
+	return 0;
+}
+
+static const struct i2c_device_id ov5640_id[] = {
+	{ "ov5640", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov5640_id);
+
+static struct i2c_driver ov5640_i2c_driver = {
+	.driver = {
+		.owner  = THIS_MODULE,
+		.name = "ov5640",
+	},
+	.probe    = ov5640_probe,
+	.remove   = ov5640_remove,
+	.id_table = ov5640_id,
+};
+
+/*
+ * module function
+ */
+
+static int __init ov5640_module_init(void)
+{
+	return i2c_add_driver(&ov5640_i2c_driver);
+}
+
+static void __exit ov5640_module_exit(void)
+{
+	i2c_del_driver(&ov5640_i2c_driver);
+}
+
+module_init(ov5640_module_init);
+module_exit(ov5640_module_exit);
+
+MODULE_DESCRIPTION("Camera driver for ov5640");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/soc_camera/ov7725.c b/drivers/media/i2c/soc_camera/ov7725.c
new file mode 100644
index 0000000..095da7c
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/ov7725.c
@@ -0,0 +1,1394 @@
+/*
+ * ov7725 Camera Driver
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * Based on ov7670 and soc_camera_platform driver,
+ *
+ * Copyright 2006-7 Jonathan Corbet <corbet@lwn.net>
+ * Copyright (C) 2008 Magnus Damm
+ * Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/module.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-subdev.h>
+#include <media/soc_camera.h>
+#include <media/soc_mediabus.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <media/ov772x.h>
+
+/*
+ * register offset
+ */
+#define GAIN        0x00 /* AGC - Gain control gain setting */
+#define BLUE        0x01 /* AWB - Blue channel gain setting */
+#define RED         0x02 /* AWB - Red   channel gain setting */
+#define GREEN       0x03 /* AWB - Green channel gain setting */
+#define COM1        0x04 /* Common control 1 */
+#define BAVG        0x05 /* U/B Average Level */
+#define GAVG        0x06 /* Y/Gb Average Level */
+#define RAVG        0x07 /* V/R Average Level */
+#define AECH        0x08 /* Exposure Value - AEC MSBs */
+#define COM2        0x09 /* Common control 2 */
+#define PID         0x0A /* Product ID Number MSB */
+#define VER         0x0B /* Product ID Number LSB */
+#define COM3        0x0C /* Common control 3 */
+#define COM4        0x0D /* Common control 4 */
+#define COM5        0x0E /* Common control 5 */
+#define COM6        0x0F /* Common control 6 */
+#define AEC         0x10 /* Exposure Value */
+#define CLKRC       0x11 /* Internal clock */
+#define COM7        0x12 /* Common control 7 */
+#define COM8        0x13 /* Common control 8 */
+#define COM9        0x14 /* Common control 9 */
+#define COM10       0x15 /* Common control 10 */
+#define REG16       0x16 /* Register 16 */
+#define HSTART      0x17 /* Horizontal sensor size */
+#define HSIZE       0x18 /* Horizontal frame (HREF column) end high 8-bit */
+#define VSTART      0x19 /* Vertical frame (row) start high 8-bit */
+#define VSIZE       0x1A /* Vertical sensor size */
+#define PSHFT       0x1B /* Data format - pixel delay select */
+#define MIDH        0x1C /* Manufacturer ID byte - high */
+#define MIDL        0x1D /* Manufacturer ID byte - low  */
+#define LAEC        0x1F /* Fine AEC value */
+#define COM11       0x20 /* Common control 11 */
+#define BDBASE      0x22 /* Banding filter Minimum AEC value */
+#define DBSTEP      0x23 /* Banding filter Maximum Setp */
+#define AEW         0x24 /* AGC/AEC - Stable operating region (upper limit) */
+#define AEB         0x25 /* AGC/AEC - Stable operating region (lower limit) */
+#define VPT         0x26 /* AGC/AEC Fast mode operating region */
+#define REG28       0x28 /* Register 28 */
+#define HOUTSIZE    0x29 /* Horizontal data output size MSBs */
+#define EXHCH       0x2A /* Dummy pixel insert MSB */
+#define EXHCL       0x2B /* Dummy pixel insert LSB */
+#define VOUTSIZE    0x2C /* Vertical data output size MSBs */
+#define ADVFL       0x2D /* LSB of insert dummy lines in Vertical direction */
+#define ADVFH       0x2E /* MSG of insert dummy lines in Vertical direction */
+#define YAVE        0x2F /* Y/G Channel Average value */
+#define LUMHTH      0x30 /* Histogram AEC/AGC Luminance high level threshold */
+#define LUMLTH      0x31 /* Histogram AEC/AGC Luminance low  level threshold */
+#define HREF        0x32 /* Image start and size control */
+#define DM_LNL      0x33 /* Dummy line low  8 bits */
+#define DM_LNH      0x34 /* Dummy line high 8 bits */
+#define ADOFF_B     0x35 /* AD offset compensation value for B  channel */
+#define ADOFF_R     0x36 /* AD offset compensation value for R  channel */
+#define ADOFF_GB    0x37 /* AD offset compensation value for Gb channel */
+#define ADOFF_GR    0x38 /* AD offset compensation value for Gr channel */
+#define OFF_B       0x39 /* Analog process B  channel offset value */
+#define OFF_R       0x3A /* Analog process R  channel offset value */
+#define OFF_GB      0x3B /* Analog process Gb channel offset value */
+#define OFF_GR      0x3C /* Analog process Gr channel offset value */
+#define COM12       0x3D /* Common control 12 */
+#define COM13       0x3E /* Common control 13 */
+#define COM14       0x3F /* Common control 14 */
+#define COM15       0x40 /* Common control 15*/
+#define COM16       0x41 /* Common control 16 */
+#define TGT_B       0x42 /* BLC blue channel target value */
+#define TGT_R       0x43 /* BLC red  channel target value */
+#define TGT_GB      0x44 /* BLC Gb   channel target value */
+#define TGT_GR      0x45 /* BLC Gr   channel target value */
+/* for ov7720 */
+#define LCC0        0x46 /* Lens correction control 0 */
+#define LCC1        0x47 /* Lens correction option 1 - X coordinate */
+#define LCC2        0x48 /* Lens correction option 2 - Y coordinate */
+#define LCC3        0x49 /* Lens correction option 3 */
+#define LCC4        0x4A /* Lens correction option 4 - radius of the circular */
+#define LCC5        0x4B /* Lens correction option 5 */
+#define LCC6        0x4C /* Lens correction option 6 */
+/* for ov7725 */
+#define LC_CTR      0x46 /* Lens correction control */
+#define LC_XC       0x47 /* X coordinate of lens correction center relative */
+#define LC_YC       0x48 /* Y coordinate of lens correction center relative */
+#define LC_COEF     0x49 /* Lens correction coefficient */
+#define LC_RADI     0x4A /* Lens correction radius */
+#define LC_COEFB    0x4B /* Lens B channel compensation coefficient */
+#define LC_COEFR    0x4C /* Lens R channel compensation coefficient */
+
+#define FIXGAIN     0x4D /* Analog fix gain amplifer */
+#define AREF0       0x4E /* Sensor reference control */
+#define AREF1       0x4F /* Sensor reference current control */
+#define AREF2       0x50 /* Analog reference control */
+#define AREF3       0x51 /* ADC    reference control */
+#define AREF4       0x52 /* ADC    reference control */
+#define AREF5       0x53 /* ADC    reference control */
+#define AREF6       0x54 /* Analog reference control */
+#define AREF7       0x55 /* Analog reference control */
+#define UFIX        0x60 /* U channel fixed value output */
+#define VFIX        0x61 /* V channel fixed value output */
+#define AWBB_BLK    0x62 /* AWB option for advanced AWB */
+#define AWB_CTRL0   0x63 /* AWB control byte 0 */
+#define DSP_CTRL1   0x64 /* DSP control byte 1 */
+#define DSP_CTRL2   0x65 /* DSP control byte 2 */
+#define DSP_CTRL3   0x66 /* DSP control byte 3 */
+#define DSP_CTRL4   0x67 /* DSP control byte 4 */
+#define AWB_BIAS    0x68 /* AWB BLC level clip */
+#define AWB_CTRL1   0x69 /* AWB control  1 */
+#define AWB_CTRL2   0x6A /* AWB control  2 */
+#define AWB_CTRL3   0x6B /* AWB control  3 */
+#define AWB_CTRL4   0x6C /* AWB control  4 */
+#define AWB_CTRL5   0x6D /* AWB control  5 */
+#define AWB_CTRL6   0x6E /* AWB control  6 */
+#define AWB_CTRL7   0x6F /* AWB control  7 */
+#define AWB_CTRL8   0x70 /* AWB control  8 */
+#define AWB_CTRL9   0x71 /* AWB control  9 */
+#define AWB_CTRL10  0x72 /* AWB control 10 */
+#define AWB_CTRL11  0x73 /* AWB control 11 */
+#define AWB_CTRL12  0x74 /* AWB control 12 */
+#define AWB_CTRL13  0x75 /* AWB control 13 */
+#define AWB_CTRL14  0x76 /* AWB control 14 */
+#define AWB_CTRL15  0x77 /* AWB control 15 */
+#define AWB_CTRL16  0x78 /* AWB control 16 */
+#define AWB_CTRL17  0x79 /* AWB control 17 */
+#define AWB_CTRL18  0x7A /* AWB control 18 */
+#define AWB_CTRL19  0x7B /* AWB control 19 */
+#define AWB_CTRL20  0x7C /* AWB control 20 */
+#define AWB_CTRL21  0x7D /* AWB control 21 */
+#define GAM1        0x7E /* Gamma Curve  1st segment input end point */
+#define GAM2        0x7F /* Gamma Curve  2nd segment input end point */
+#define GAM3        0x80 /* Gamma Curve  3rd segment input end point */
+#define GAM4        0x81 /* Gamma Curve  4th segment input end point */
+#define GAM5        0x82 /* Gamma Curve  5th segment input end point */
+#define GAM6        0x83 /* Gamma Curve  6th segment input end point */
+#define GAM7        0x84 /* Gamma Curve  7th segment input end point */
+#define GAM8        0x85 /* Gamma Curve  8th segment input end point */
+#define GAM9        0x86 /* Gamma Curve  9th segment input end point */
+#define GAM10       0x87 /* Gamma Curve 10th segment input end point */
+#define GAM11       0x88 /* Gamma Curve 11th segment input end point */
+#define GAM12       0x89 /* Gamma Curve 12th segment input end point */
+#define GAM13       0x8A /* Gamma Curve 13th segment input end point */
+#define GAM14       0x8B /* Gamma Curve 14th segment input end point */
+#define GAM15       0x8C /* Gamma Curve 15th segment input end point */
+#define SLOP        0x8D /* Gamma curve highest segment slope */
+#define DNSTH       0x8E /* De-noise threshold */
+#define EDGE_STRNGT 0x8F /* Edge strength  control when manual mode */
+#define EDGE_TRSHLD 0x90 /* Edge threshold control when manual mode */
+#define DNSOFF      0x91 /* Auto De-noise threshold control */
+#define EDGE_UPPER  0x92 /* Edge strength upper limit when Auto mode */
+#define EDGE_LOWER  0x93 /* Edge strength lower limit when Auto mode */
+#define MTX1        0x94 /* Matrix coefficient 1 */
+#define MTX2        0x95 /* Matrix coefficient 2 */
+#define MTX3        0x96 /* Matrix coefficient 3 */
+#define MTX4        0x97 /* Matrix coefficient 4 */
+#define MTX5        0x98 /* Matrix coefficient 5 */
+#define MTX6        0x99 /* Matrix coefficient 6 */
+#define MTX_CTRL    0x9A /* Matrix control */
+#define BRIGHT      0x9B /* Brightness control */
+#define CNTRST      0x9C /* Contrast contrast */
+#define CNTRST_CTRL 0x9D /* Contrast contrast center */
+#define UVAD_J0     0x9E /* Auto UV adjust contrast 0 */
+#define UVAD_J1     0x9F /* Auto UV adjust contrast 1 */
+#define SCAL0       0xA0 /* Scaling control 0 */
+#define SCAL1       0xA1 /* Scaling control 1 */
+#define SCAL2       0xA2 /* Scaling control 2 */
+#define FIFODLYM    0xA3 /* FIFO manual mode delay control */
+#define FIFODLYA    0xA4 /* FIFO auto   mode delay control */
+#define SDE         0xA6 /* Special digital effect control */
+#define USAT        0xA7 /* U component saturation control */
+#define VSAT        0xA8 /* V component saturation control */
+/* for ov7720 */
+#define HUE0        0xA9 /* Hue control 0 */
+#define HUE1        0xAA /* Hue control 1 */
+/* for ov7725 */
+#define HUECOS      0xA9 /* Cosine value */
+#define HUESIN      0xAA /* Sine value */
+
+#define SIGN        0xAB /* Sign bit for Hue and contrast */
+#define DSPAUTO     0xAC /* DSP auto function ON/OFF control */
+
+/*
+ * register detail
+ */
+
+/* COM2 */
+#define SOFT_SLEEP_MODE 0x10	/* Soft sleep mode */
+				/* Output drive capability */
+#define OCAP_1x         0x00	/* 1x */
+#define OCAP_2x         0x01	/* 2x */
+#define OCAP_3x         0x02	/* 3x */
+#define OCAP_4x         0x03	/* 4x */
+
+/* COM3 */
+#define SWAP_MASK       (SWAP_RGB | SWAP_YUV | SWAP_ML)
+#define IMG_MASK        (VFLIP_IMG | HFLIP_IMG)
+
+#define VFLIP_IMG       0x80	/* Vertical flip image ON/OFF selection */
+#define HFLIP_IMG       0x40	/* Horizontal mirror image ON/OFF selection */
+#define SWAP_RGB        0x20	/* Swap B/R  output sequence in RGB mode */
+#define SWAP_YUV        0x10	/* Swap Y/UV output sequence in YUV mode */
+#define SWAP_ML         0x08	/* Swap output MSB/LSB */
+				/* Tri-state option for output clock */
+#define NOTRI_CLOCK     0x04	/*   0: Tri-state    at this period */
+				/*   1: No tri-state at this period */
+				/* Tri-state option for output data */
+#define NOTRI_DATA      0x02	/*   0: Tri-state    at this period */
+				/*   1: No tri-state at this period */
+#define SCOLOR_TEST     0x01	/* Sensor color bar test pattern */
+
+/* COM4 */
+				/* PLL frequency control */
+#define PLL_BYPASS      0x00	/*  00: Bypass PLL */
+#define PLL_4x          0x40	/*  01: PLL 4x */
+#define PLL_6x          0x80	/*  10: PLL 6x */
+#define PLL_8x          0xc0	/*  11: PLL 8x */
+				/* AEC evaluate window */
+#define AEC_FULL        0x00	/*  00: Full window */
+#define AEC_1p2         0x10	/*  01: 1/2  window */
+#define AEC_1p4         0x20	/*  10: 1/4  window */
+#define AEC_2p3         0x30	/*  11: Low 2/3 window */
+
+/* COM5 */
+#define AFR_ON_OFF      0x80	/* Auto frame rate control ON/OFF selection */
+#define AFR_SPPED       0x40	/* Auto frame rate control speed selection */
+				/* Auto frame rate max rate control */
+#define AFR_NO_RATE     0x00	/*     No  reduction of frame rate */
+#define AFR_1p2         0x10	/*     Max reduction to 1/2 frame rate */
+#define AFR_1p4         0x20	/*     Max reduction to 1/4 frame rate */
+#define AFR_1p8         0x30	/* Max reduction to 1/8 frame rate */
+				/* Auto frame rate active point control */
+#define AF_2x           0x00	/*     Add frame when AGC reaches  2x gain */
+#define AF_4x           0x04	/*     Add frame when AGC reaches  4x gain */
+#define AF_8x           0x08	/*     Add frame when AGC reaches  8x gain */
+#define AF_16x          0x0c	/* Add frame when AGC reaches 16x gain */
+				/* AEC max step control */
+#define AEC_NO_LIMIT    0x01	/*   0 : AEC incease step has limit */
+				/*   1 : No limit to AEC increase step */
+
+/* COM7 */
+				/* SCCB Register Reset */
+#define SCCB_RESET      0x80	/*   0 : No change */
+				/*   1 : Resets all registers to default */
+				/* Resolution selection */
+#define SLCT_MASK       0x60	/*   Mask of VGA or QVGA + itu656 */
+#define SLCT_VGA        0x00	/*   0 : VGA */
+#define SLCT_QVGA       0x40	/*   1 : QVGA */
+#define ITU656_ON_OFF   0x20	/* ITU656 protocol ON/OFF selection */
+				/* RGB output format control */
+#define FMT_MASK        0x0c	/*      Mask of color format */
+#define FMT_GBR422      0x00	/*      00 : GBR 4:2:2 */
+#define FMT_RGB565      0x04	/*      01 : RGB 565 */
+#define FMT_RGB555      0x08	/*      10 : RGB 555 */
+#define FMT_RGB444      0x0c	/* 11 : RGB 444 */
+				/* Output format control */
+#define OFMT_MASK       0x03    /*      Mask of output format */
+#define OFMT_YUV        0x00	/*      00 : YUV */
+#define OFMT_P_BRAW     0x01	/*      01 : Processed Bayer RAW */
+#define OFMT_RGB        0x02	/*      10 : RGB */
+#define OFMT_BRAW       0x03	/* 11 : Bayer RAW */
+
+/* COM8 */
+#define FAST_ALGO       0x80	/* Enable fast AGC/AEC algorithm */
+				/* AEC Setp size limit */
+#define UNLMT_STEP      0x40	/*   0 : Step size is limited */
+				/*   1 : Unlimited step size */
+#define BNDF_ON_OFF     0x20	/* Banding filter ON/OFF */
+#define AEC_BND         0x10	/* Enable AEC below banding value */
+#define AEC_ON_OFF      0x08	/* Fine AEC ON/OFF control */
+#define AGC_ON          0x04	/* AGC Enable */
+#define AWB_ON          0x02	/* AWB Enable */
+#define AEC_ON          0x01	/* AEC Enable */
+
+/* COM9 */
+#define BASE_AECAGC     0x80	/* Histogram or average based AEC/AGC */
+				/* Automatic gain ceiling - maximum AGC value */
+#define GAIN_2x         0x00	/*    000 :   2x */
+#define GAIN_4x         0x10	/*    001 :   4x */
+#define GAIN_8x         0x20	/*    010 :   8x */
+#define GAIN_16x        0x30	/*    011 :  16x */
+#define GAIN_32x        0x40	/*    100 :  32x */
+#define GAIN_64x        0x50	/* 101 :  64x */
+#define GAIN_128x       0x60	/* 110 : 128x */
+#define DROP_VSYNC      0x04	/* Drop VSYNC output of corrupt frame */
+#define DROP_HREF       0x02	/* Drop HREF  output of corrupt frame */
+
+/* COM11 */
+#define SGLF_ON_OFF     0x02	/* Single frame ON/OFF selection */
+#define SGLF_TRIG       0x01	/* Single frame transfer trigger */
+
+/* EXHCH */
+#define VSIZE_LSB       0x04	/* Vertical data output size LSB */
+
+/* DSP_CTRL1 */
+#define FIFO_ON         0x80	/* FIFO enable/disable selection */
+#define UV_ON_OFF       0x40	/* UV adjust function ON/OFF selection */
+#define YUV444_2_422    0x20	/* YUV444 to 422 UV channel option selection */
+#define CLR_MTRX_ON_OFF 0x10	/* Color matrix ON/OFF selection */
+#define INTPLT_ON_OFF   0x08	/* Interpolation ON/OFF selection */
+#define GMM_ON_OFF      0x04	/* Gamma function ON/OFF selection */
+#define AUTO_BLK_ON_OFF 0x02	/* Black defect auto correction ON/OFF */
+#define AUTO_WHT_ON_OFF 0x01	/* White define auto correction ON/OFF */
+
+/* DSP_CTRL3 */
+#define UV_MASK         0x80	/* UV output sequence option */
+#define UV_ON           0x80	/*   ON */
+#define UV_OFF          0x00	/*   OFF */
+#define CBAR_MASK       0x20	/* DSP Color bar mask */
+#define CBAR_ON         0x20	/*   ON */
+#define CBAR_OFF        0x00	/*   OFF */
+
+/* HSTART */
+#define HST_VGA         0x23
+#define HST_QVGA        0x3F
+
+/* HSIZE */
+#define HSZ_VGA         0xA0
+#define HSZ_QVGA        0x50
+
+/* VSTART */
+#define VST_VGA         0x07
+#define VST_QVGA        0x03
+
+/* VSIZE */
+#define VSZ_VGA         0xF0
+#define VSZ_QVGA        0x78
+
+/* HOUTSIZE */
+#define HOSZ_VGA        0xA0
+#define HOSZ_QVGA       0x50
+
+/* VOUTSIZE */
+#define VOSZ_VGA        0xF0
+#define VOSZ_QVGA       0x78
+
+/* DSPAUTO (DSP Auto Function ON/OFF Control) */
+#define AWB_ACTRL       0x80 /* AWB auto threshold control */
+#define DENOISE_ACTRL   0x40 /* De-noise auto threshold control */
+#define EDGE_ACTRL      0x20 /* Edge enhancement auto strength control */
+#define UV_ACTRL        0x10 /* UV adjust auto slope control */
+#define SCAL0_ACTRL     0x08 /* Auto scaling factor control */
+#define SCAL1_2_ACTRL   0x04 /* Auto scaling factor control */
+
+/*
+ * ID
+ */
+#define OV7720  0x7720
+#define OV7725  0x7721
+#define VERSION(pid, ver) ((pid<<8)|(ver&0xFF))
+
+static int debug;
+module_param(debug, int, 0);
+MODULE_PARM_DESC(debug, "Debug level (0-2)");
+
+
+/*
+ * struct
+ */
+struct regval_list {
+	unsigned char reg_num;
+	unsigned char value;
+};
+
+struct ov7725_color_format {
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+	u8 dsp3;
+	u8 com3;
+	u8 com7;
+};
+
+struct ov7725_win_size {
+	char                     *name;
+	__u32                     width;
+	__u32                     height;
+	unsigned char             com7_bit;
+	const struct regval_list *regs;
+};
+
+struct ov7725 {
+	struct v4l2_subdev                sd;
+	struct ov772x_camera_info        *info;
+	const struct ov7725_color_format *cfmt;
+	const struct ov7725_win_size     *win;
+	int                               model;
+	unsigned short                    vflip:1;
+	unsigned short                    hflip:1;
+	/* band_filter = COM8[5] ? 256 - BDBASE : 0 */
+	unsigned short                    band_filter;
+};
+
+#define ENDMARKER { 0xff, 0xff }
+
+/*
+ * register setting for window size
+ */
+static const struct regval_list ov7725_qvga_regs[] = {
+	{ HSTART,   HST_QVGA },
+	{ HSIZE,    HSZ_QVGA },
+	{ VSTART,   VST_QVGA },
+	{ VSIZE,    VSZ_QVGA  },
+	{ HOUTSIZE, HOSZ_QVGA },
+	{ VOUTSIZE, VOSZ_QVGA },
+	ENDMARKER,
+};
+
+static const struct regval_list ov7725_vga_regs[] = {
+#ifdef CONFIG_MACH_IWG21M
+	/*IWG21M: Camera: Working register settings for OV7725 Chip */
+        {0x12, 0x80},
+	/*IWG21M: Camera: Added below register setting to get proper output data from Camera*/
+        {0x12, 0x24},
+        {0x03, 0x80},
+        {0x3d, 0x03},
+        {0x17, 0x22},
+        {0x18, 0xa4},
+        {0x19, 0x07},
+        {0x1a, 0xf0},
+        {0x32, 0x00},
+        {0x29, 0xa0},
+        {0x2c, 0xf0},
+        {0x2a, 0x00},
+        {0x11, 0x03},
+        {0x42, 0x7f},
+        {0x4d, 0x09},
+        {0x63, 0xe0},
+        {0x64, 0xff},
+        {0x65, 0x20},
+        {0x66, 0x00},
+        {0x67, 0x48},
+        {0x13, 0xf0},
+        {0x0d, 0x41},
+        {0x0f, 0xc5},
+        {0x14, 0x11},
+        {0x22, 0x3f},
+        {0x23, 0x07},
+        {0x24, 0x40},
+        {0x25, 0x30},
+        {0x26, 0xa1},
+        {0x2b, 0x00},
+        {0x6b, 0xaa},
+        {0x13, 0xff},
+        {0x90, 0x05},
+        {0x91, 0x01},
+        {0x92, 0x03},
+        {0x93, 0x00},
+        {0x94, 0xb0},
+        {0x95, 0x9d},
+        {0x96, 0x13},
+        {0x97, 0x16},
+        {0x98, 0x7b},
+        {0x99, 0x91},
+        {0x9a, 0x1e},
+        {0x9b, 0x08},
+        {0x9c, 0x20},
+        {0x9e, 0x81},
+        {0xa6, 0x04},
+        {0x7e, 0x0c},
+        {0x7f, 0x16},
+        {0x80, 0x2a},
+        {0x81, 0x4e},
+        {0x82, 0x61},
+        {0x83, 0x6f},
+        {0x84, 0x7b},
+        {0x85, 0x86},
+        {0x86, 0x8e},
+        {0x87, 0x97},
+        {0x88, 0xa4},
+        {0x89, 0xaf},
+        {0x8a, 0xc5},
+        {0x8b, 0xd7},
+        {0x8c, 0xe8},
+        {0x8d, 0x20},
+        {0x11, 0x01},
+        {0x22, 0x9f}, /*0x99*/
+        {0x23, 0x03},
+	/*IWG21M: Camera: Added below register setting to get proper output data from Camera*/
+        {0xc, 0x00},
+#else
+	{ HSTART,   HST_VGA },
+	{ HSIZE,    HSZ_VGA },
+	{ VSTART,   VST_VGA },
+	{ VSIZE,    VSZ_VGA },
+	{ HOUTSIZE, HOSZ_VGA },
+	{ VOUTSIZE, VOSZ_VGA },
+#endif
+	ENDMARKER,
+};
+
+/*
+ * supported color format list
+ */
+static const struct ov7725_color_format ov7725_cfmts[] = {
+	{
+		.code		= V4L2_MBUS_FMT_YUYV8_2X8,
+		.colorspace	= V4L2_COLORSPACE_JPEG,
+		.dsp3		= 0x0,
+		.com3		= SWAP_YUV,
+		.com7		= OFMT_YUV | ITU656_ON_OFF ,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_YVYU8_2X8,
+		.colorspace	= V4L2_COLORSPACE_JPEG,
+		.dsp3		= UV_ON,
+		.com3		= SWAP_YUV,
+		.com7		= OFMT_YUV | ITU656_ON_OFF,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_UYVY8_2X8,
+		.colorspace	= V4L2_COLORSPACE_JPEG,
+		.dsp3		= 0x0,
+		.com3		= 0x0,
+		.com7		= OFMT_YUV | ITU656_ON_OFF ,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.dsp3		= 0x0,
+		.com3		= SWAP_RGB,
+		.com7		= FMT_RGB555 | OFMT_RGB,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_RGB555_2X8_PADHI_BE,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.dsp3		= 0x0,
+		.com3		= 0x0,
+		.com7		= FMT_RGB555 | OFMT_RGB,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_RGB565_2X8_LE,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.dsp3		= 0x0,
+		.com3		= SWAP_RGB,
+		.com7		= FMT_RGB565 | OFMT_RGB,
+	},
+	{
+		.code		= V4L2_MBUS_FMT_RGB565_2X8_BE,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.dsp3		= 0x0,
+		.com3		= 0x0,
+		.com7		= FMT_RGB565 | OFMT_RGB,
+	},
+};
+
+/*
+ * window size list
+ */
+#define VGA_WIDTH   640
+#define VGA_HEIGHT  480
+#define QVGA_WIDTH  320
+#define QVGA_HEIGHT 240
+#define MAX_WIDTH   VGA_WIDTH
+#define MAX_HEIGHT  VGA_HEIGHT
+
+static const struct ov7725_win_size ov7725_win_vga = {
+	.name     = "VGA",
+	.width    = VGA_WIDTH,
+	.height   = VGA_HEIGHT,
+	.com7_bit = SLCT_VGA,
+	.regs     = ov7725_vga_regs,
+};
+
+static const struct ov7725_win_size ov7725_win_qvga = {
+	.name     = "QVGA",
+	.width    = QVGA_WIDTH,
+	.height   = QVGA_HEIGHT,
+	.com7_bit = SLCT_QVGA,
+	.regs     = ov7725_qvga_regs,
+};
+
+static const struct v4l2_queryctrl ov7725_qctrl[] = {
+	{
+		.id		= V4L2_CID_VFLIP,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Flip Vertically",
+		.minimum	= 0,
+		.maximum	= 1,
+		.step		= 1,
+		.default_value	= 0,
+	},
+	{
+		.id		= V4L2_CID_HFLIP,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Flip Horizontally",
+		.minimum	= 0,
+		.maximum	= 1,
+		.step		= 1,
+		.default_value	= 0,
+	},
+	{
+		.id		= V4L2_CID_BAND_STOP_FILTER,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Band-stop filter",
+		.minimum	= 0,
+		.maximum	= 256,
+		.step		= 1,
+		.default_value	= 0,
+	},
+};
+
+/*
+ * general function
+ */
+
+static struct ov7725_priv *to_ov7725(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ov7725, sd);
+}
+
+static int ov7725_read(struct v4l2_subdev *sd, unsigned char addr)
+{
+        struct i2c_client *c = v4l2_get_subdevdata(sd);
+        unsigned char buffer[1];
+        int rc;
+
+        buffer[0] = addr;
+        if (1 != (rc = i2c_master_send(c, buffer, 1)))
+                v4l2_dbg(0, debug, sd, "i2c i/o error: rc == %d (should be 1)\n", rc);
+
+        msleep(10);
+
+        if (1 != (rc = i2c_master_recv(c, buffer, 1)))
+                v4l2_dbg(0, debug, sd, "i2c i/o error: rc == %d (should be 1)\n", rc);
+
+        v4l2_dbg(2, debug, sd, "ov7725: read 0x%02x = 0x%02x\n", addr, buffer[0]);
+
+        return (buffer[0]);
+}
+
+static inline int ov7725_write(struct v4l2_subdev *sd, unsigned char addr,
+                                 unsigned char value)
+{
+        struct i2c_client *c = v4l2_get_subdevdata(sd);
+        unsigned char buffer[2];
+        int rc;
+
+        buffer[0] = addr;
+        buffer[1] = value;
+        v4l2_dbg(2, debug, sd, "ov7725: writing 0x%02x 0x%02x\n", buffer[0], buffer[1]);
+        if (2 != (rc = i2c_master_send(c, buffer, 2))){
+                v4l2_dbg(0, debug, sd, "i2c i/o error: rc == %d (should be 2)\n", rc);
+		return -1;
+	}
+	return 0;
+}
+
+static inline int ov7725_mask_set(struct v4l2_subdev *sd, unsigned char addr,
+					  u8  mask, u8  set)
+{
+	u8 val = ov7725_read (sd, addr);
+
+	val &= ~mask;
+	val |= set & mask;
+
+	return ov7725_write (sd, addr, val);
+}
+
+static int ov7725_write_array(struct v4l2_subdev *sd,
+			      const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = ov7725_write(sd, vals->reg_num,
+					    vals->value);
+		if (ret < 0)
+			return ret;
+		vals++;
+	}
+	return 0;
+}
+
+static int ov7725_reset(struct v4l2_subdev *sd, u32 val)
+{
+	int ret = ov7725_write (sd, COM7, SCCB_RESET);
+	msleep(1);
+	return ret;
+}
+
+/*
+ * soc_camera_ops function
+ */
+
+static int ov7725_s_stream(struct v4l2_subdev *sd, int enable)
+{
+        struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov7725 *core = to_ov7725(sd);
+
+	if (!enable) {
+		ov7725_mask_set(sd, COM2, SOFT_SLEEP_MODE, SOFT_SLEEP_MODE);
+		return 0;
+	}
+#ifndef CONFIG_MACH_IWG21M
+	/*IWG21M: Camera: Commented below line for not to reset register settings */
+	ov7725_reset(sd, 0);
+#endif
+
+	if (!core->win || !core->cfmt) {
+		dev_err(&client->dev, "norm or win select error\n");
+		return -EPERM;
+	}
+
+	ov7725_mask_set(sd, COM2, SOFT_SLEEP_MODE, 0);
+
+	dev_dbg(&client->dev, "format %d, win %s\n",
+		core->cfmt->code, core->win->name);
+
+	return 0;
+}
+
+static int ov7725_set_bus_param(struct soc_camera_device *icd,
+				unsigned long		  flags)
+{
+	return 0;
+}
+
+static unsigned long ov7725_query_bus_param(struct soc_camera_device *icd)
+{
+	return 0;
+}
+
+static int ov7725_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+        int i;
+
+        v4l2_dbg(1, debug, sd, "queryctrl called\n");
+
+        for (i = 0; i < ARRAY_SIZE(ov7725_qctrl); i++)
+                if (qc->id && qc->id == ov7725_qctrl[i].id) {
+                        memcpy(qc, &(ov7725_qctrl[i]),
+                               sizeof(*qc));
+                        return 0;
+                }
+
+        return -EINVAL;
+}
+
+static int ov7725_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov7725 *core = to_ov7725(sd);
+
+	switch (ctrl->id) {
+	case V4L2_CID_VFLIP:
+		ctrl->value = core->vflip;
+		return 0;
+	case V4L2_CID_HFLIP:
+		ctrl->value = core->hflip;
+		return 0;
+	case V4L2_CID_BAND_STOP_FILTER:
+		ctrl->value = core->band_filter;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int ov7725_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov7725 *core = to_ov7725(sd);
+	int ret = 0;
+	u8 val;
+	u8 i, n;
+        n = ARRAY_SIZE(ov7725_qctrl);
+
+        for (i = 0; i < n; i++) {
+                if (ctrl->id != ov7725_qctrl[i].id)
+                        continue;
+                if (ctrl->value < ov7725_qctrl[i].minimum ||
+                    ctrl->value > ov7725_qctrl[i].maximum)
+                        return -ERANGE;
+                v4l2_dbg(1, debug, sd, "s_ctrl: id=%d, value=%d\n",
+                                        ctrl->id, ctrl->value);
+                break;
+        }
+
+
+	switch (ctrl->id) {
+	case V4L2_CID_VFLIP:
+		val = ctrl->value ? VFLIP_IMG : 0x00;
+		core->vflip = ctrl->value;
+		return ov7725_mask_set(sd, COM3, VFLIP_IMG, val);
+	case V4L2_CID_HFLIP:
+		val = ctrl->value ? HFLIP_IMG : 0x00;
+		core->hflip = ctrl->value;
+		return ov7725_mask_set(sd, COM3, HFLIP_IMG, val);
+	case V4L2_CID_BAND_STOP_FILTER:
+		if ((unsigned)ctrl->value > 256)
+			ctrl->value = 256;
+		if (ctrl->value == core->band_filter)
+			return 0;
+		if (!ctrl->value) {
+			/* Switch the filter off, it is on now */
+			ret = ov7725_mask_set(sd, BDBASE, 0xff, 0xff);
+			if (!ret)
+				ret = ov7725_mask_set(sd, COM8, BNDF_ON_OFF, 0);
+		} else {
+			/* Switch the filter on, set AEC low limit */
+			val = 256 - ctrl->value;
+			ret = ov7725_mask_set(sd, COM8, BNDF_ON_OFF, BNDF_ON_OFF);
+			if (!ret)
+				ret = ov7725_mask_set(sd, BDBASE, 0xff, val);
+		}
+		if (!ret)
+			core->band_filter = ctrl->value;
+		return ret;
+	}
+
+	return -EINVAL;
+}
+
+static int ov7725_g_chip_ident(struct v4l2_subdev *sd,
+			       struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV7725,
+                                          0);
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov7725_g_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	int ret;
+
+	reg->size = 1;
+	if (reg->reg > 0xff)
+		return -EINVAL;
+
+	ret = ov7725_read(sd, reg->reg);
+	if (ret < 0)
+		return ret;
+
+	reg->val = (__u64)ret;
+
+	return 0;
+}
+
+static int ov7725_s_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+
+	if (reg->reg > 0xff ||
+	    reg->val > 0xff)
+		return -EINVAL;
+
+	ov7725_write (sd, reg->reg, reg->val);
+
+	return 0;
+}
+#endif
+
+static const struct ov7725_win_size *ov7725_select_win_vga(void)
+{
+	const struct ov7725_win_size *win;
+
+    /* alway select vga */
+	win = &ov7725_win_vga;
+	return win;
+}
+
+static const struct ov7725_win_size *ov7725_select_win(u32 width, u32 height)
+{
+	__u32 diff;
+	const struct ov7725_win_size *win;
+
+	/* default is QVGA */
+	diff = abs(width - ov7725_win_qvga.width) +
+		abs(height - ov7725_win_qvga.height);
+	win = &ov7725_win_qvga;
+
+	/* VGA */
+	if (diff >
+	    abs(width  - ov7725_win_vga.width) +
+	    abs(height - ov7725_win_vga.height))
+		win = &ov7725_win_vga;
+
+	return win;
+}
+
+static int ov7725_set_params(struct v4l2_subdev *sd, u32 *width, u32 *height,
+			     enum v4l2_mbus_pixelcode code)
+{
+	struct ov7725 *core = to_ov7725(sd);
+	int ret = -EINVAL;
+	u8  val;
+	int i;
+
+	/*
+	 * select format
+	 */
+	core->cfmt = NULL;
+	for (i = 0; i < ARRAY_SIZE(ov7725_cfmts); i++) {
+		if (code == ov7725_cfmts[i].code) {
+			core->cfmt = ov7725_cfmts + i;
+			break;
+		}
+	}
+	if (!core->cfmt)
+		goto ov7725_set_fmt_error;
+
+	/*
+	 * select win
+	core->win = ov7725_select_win(*width, *height);
+	 */
+	core->win = ov7725_select_win_vga();
+
+	/*
+	 * reset hardware
+	 */
+	ov7725_reset(sd, 0);
+
+#ifndef CONFIG_MACH_IWG21M
+	/*IWG21M: Camera: Commented below register settings since we are not using those settings */
+	/*
+	 * Edge Ctrl
+	 */
+	if (core->info->edgectrl.strength & OV772X_MANUAL_EDGE_CTRL) {
+
+		/*
+		 * Manual Edge Control Mode
+		 *
+		 * Edge auto strength bit is set by default.
+		 * Remove it when manual mode.
+		 */
+
+		ret = ov7725_mask_set(sd, DSPAUTO, EDGE_ACTRL, 0x00);
+		if (ret < 0)
+			goto ov7725_set_fmt_error;
+
+		ret = ov7725_mask_set(sd,
+				      EDGE_TRSHLD, OV772X_EDGE_THRESHOLD_MASK,
+				      core->info->edgectrl.threshold);
+		if (ret < 0)
+			goto ov7725_set_fmt_error;
+
+		ret = ov7725_mask_set(sd,
+				      EDGE_STRNGT, OV772X_EDGE_STRENGTH_MASK,
+				      core->info->edgectrl.strength);
+		if (ret < 0)
+			goto ov7725_set_fmt_error;
+
+	} else if (core->info->edgectrl.upper > core->info->edgectrl.lower) {
+		/*
+		 * Auto Edge Control Mode
+		 *
+		 * set upper and lower limit
+		 */
+		ret = ov7725_mask_set(sd,
+				      EDGE_UPPER, OV772X_EDGE_UPPER_MASK,
+				      core->info->edgectrl.upper);
+		if (ret < 0)
+			goto ov7725_set_fmt_error;
+
+		ret = ov7725_mask_set(sd,
+				      EDGE_LOWER, OV772X_EDGE_LOWER_MASK,
+				      core->info->edgectrl.lower);
+		if (ret < 0)
+			goto ov7725_set_fmt_error;
+	}
+#endif
+
+	/*
+	 * set size format
+	 */
+	ret = ov7725_write_array(sd, core->win->regs);
+	if (ret < 0)
+		goto ov7725_set_fmt_error;
+
+#ifndef CONFIG_MACH_IWG21M
+	/*IWG21M: Camera: Commented below register settings since we are not using those settings */
+
+	/*
+	 * set DSP_CTRL3
+	 */
+	val = core->cfmt->dsp3;
+	if (val) {
+		ret = ov7725_mask_set(sd,
+				      DSP_CTRL3, UV_MASK, val);
+		if (ret < 0)
+			goto ov7725_set_fmt_error;
+	}
+
+	/*
+	 * set COM3
+	 */
+	val = core->cfmt->com3;
+	if (core->info->flags & OV772X_FLAG_VFLIP)
+		val |= VFLIP_IMG;
+	if (core->info->flags & OV772X_FLAG_HFLIP)
+		val |= HFLIP_IMG;
+	if (core->vflip)
+		val ^= VFLIP_IMG;
+	if (core->hflip)
+		val ^= HFLIP_IMG;
+
+	ret = ov7725_mask_set(sd,
+			      COM3, SWAP_MASK | IMG_MASK, val);
+	if (ret < 0)
+		goto ov7725_set_fmt_error;
+
+	/*
+	 * set COM7
+	 */
+	val = core->win->com7_bit | core->cfmt->com7;
+	ret = ov7725_mask_set(sd,
+			      COM7, SLCT_MASK | FMT_MASK | OFMT_MASK,
+			      val);
+	if (ret < 0)
+		goto ov7725_set_fmt_error;
+
+	/*
+	 * set COM8
+	 */
+	if (core->band_filter) {
+		ret = ov7725_mask_set(sd, COM8, BNDF_ON_OFF, 1);
+		if (!ret)
+			ret = ov7725_mask_set(sd, BDBASE,
+					      0xff, 256 - core->band_filter);
+		if (ret < 0)
+			goto ov7725_set_fmt_error;
+	}
+#endif
+	/*
+	 * set COM7
+	 */
+	val = core->win->com7_bit | core->cfmt->com7;
+	ret = ov7725_mask_set(sd,
+			      COM7, SLCT_MASK | FMT_MASK | OFMT_MASK,
+			      val);
+	if (ret < 0)
+		goto ov7725_set_fmt_error;
+
+
+	*width = core->win->width;
+	*height = core->win->height;
+
+	return ret;
+
+ov7725_set_fmt_error:
+
+	ov7725_reset(sd, 0);
+	core->win = NULL;
+	core->cfmt = NULL;
+
+	return ret;
+}
+
+static int ov7725_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov7725 *core = to_ov7725(sd);
+
+	a->c.left	= 0;
+	a->c.top	= 0;
+	a->c.width	= core->win->width;
+	a->c.height	= core->win->height;
+	a->type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	dev_dbg(&client->dev, "In ov7725_g_crop w %d, h %d\n",
+		a->c.width, a->c.height);
+
+	return 0;
+}
+
+static int ov7725_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov7725 *core = to_ov7725(sd);
+
+	a->bounds.left			= 0;
+	a->bounds.top			= 0;
+	a->bounds.width	= core->win->width;
+	a->bounds.height = core->win->height;
+	a->defrect			= a->bounds;
+	a->type				= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	a->pixelaspect.numerator	= 1;
+	a->pixelaspect.denominator	= 1;
+
+	dev_dbg(&client->dev, "In ov7725_cropcap w %d, h %d\n",
+		a->bounds.width, a->bounds.height);
+	return 0;
+}
+
+static int ov7725_g_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *mf)
+{
+	struct ov7725 *core = to_ov7725(sd);
+
+	if (!core->win || !core->cfmt) {
+		u32 width = VGA_WIDTH, height = VGA_HEIGHT;
+		int ret = ov7725_set_params(sd, &width, &height,
+					    V4L2_MBUS_FMT_YUYV8_2X8);
+		if (ret < 0)
+			return ret;
+	}
+
+	mf->width	= core->win->width;
+	mf->height	= core->win->height;
+	mf->code	= core->cfmt->code;
+	mf->colorspace	= core->cfmt->colorspace;
+	mf->field	= V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov7725_s_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *mf)
+{
+	struct ov7725 *core = to_ov7725(sd);
+	int ret = ov7725_set_params(sd, &mf->width, &mf->height,
+				    mf->code);
+
+	if (!ret)
+		mf->colorspace = core->cfmt->colorspace;
+
+	return ret;
+}
+
+static int ov7725_try_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_mbus_framefmt *mf)
+{
+	struct ov7725 *core = to_ov7725(sd);
+	const struct ov7725_win_size *win;
+	int i;
+
+	/*
+	 * select suitable win
+	win = ov7725_select_win(mf->width, mf->height);
+	 */
+	win = ov7725_select_win_vga();
+
+	mf->width	= win->width;
+	mf->height	= win->height;
+	mf->field	= V4L2_FIELD_NONE;
+
+	for (i = 0; i < ARRAY_SIZE(ov7725_cfmts); i++)
+		if (mf->code == ov7725_cfmts[i].code)
+			break;
+
+	if (i == ARRAY_SIZE(ov7725_cfmts)) {
+		/* Unsupported format requested. Propose either */
+		if (core->cfmt) {
+			/* the current one or */
+			mf->colorspace = core->cfmt->colorspace;
+			mf->code = core->cfmt->code;
+		} else {
+			/* the default one */
+			mf->colorspace = ov7725_cfmts[0].colorspace;
+			mf->code = ov7725_cfmts[0].code;
+		}
+	} else {
+		/* Also return the colorspace */
+		mf->colorspace	= ov7725_cfmts[i].colorspace;
+	}
+
+	return 0;
+}
+
+static int ov7725_video_probe (struct v4l2_subdev *sd)
+{
+	u8 pid, ver;
+	const char         *devname;
+        struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov7725 *core = to_ov7725(sd);
+
+	/*
+	 * check and show product ID and manufacturer ID
+	 */
+	pid = ov7725_read(sd, PID);
+	ver = ov7725_read(sd, VER);
+	switch (VERSION(pid, ver)) {
+	case OV7725:
+		devname     = "ov7725";
+		core->model = V4L2_IDENT_OV7725;
+		break;
+	default:
+		dev_err(&client->dev, "Product ID error %x:%x\n", pid, ver);
+		return -ENODEV;
+	}
+
+	dev_info(&client->dev,
+		 "%s: Product ID %0x:%0x Manufacturer ID %x:%x\n",
+		 devname,
+		 pid,
+		 ver,
+		 ov7725_read(sd, MIDH),
+		 ov7725_read(sd, MIDL));
+	return 0;
+
+}
+
+static struct v4l2_subdev_core_ops ov7725_subdev_core_ops = {
+	.reset		= ov7725_reset,
+	.queryctrl      = ov7725_queryctrl,
+	.g_ctrl		= ov7725_g_ctrl,
+	.s_ctrl		= ov7725_s_ctrl,
+	.g_chip_ident	= ov7725_g_chip_ident,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register	= ov7725_g_register,
+	.s_register	= ov7725_s_register,
+#endif
+};
+
+static int ov7725_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+			   enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= ARRAY_SIZE(ov7725_cfmts))
+		return -EINVAL;
+
+	*code = ov7725_cfmts[index].code;
+	return 0;
+}
+
+static int ov7725_g_mbus_config(struct v4l2_subdev *sd,
+				struct v4l2_mbus_config *cfg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
+
+	cfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_MASTER |
+		V4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_HIGH |
+		V4L2_MBUS_DATA_ACTIVE_HIGH;
+	cfg->type = V4L2_MBUS_PARALLEL;
+	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
+
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops ov7725_subdev_video_ops = {
+	.s_stream	= ov7725_s_stream,
+	.g_mbus_fmt	= ov7725_g_fmt,
+	.s_mbus_fmt	= ov7725_s_fmt,
+	.try_mbus_fmt	= ov7725_try_fmt,
+	.cropcap	= ov7725_cropcap,
+	.g_crop		= ov7725_g_crop,
+	.enum_mbus_fmt	= ov7725_enum_fmt,
+	.g_mbus_config  = ov7725_g_mbus_config,
+};
+
+static struct v4l2_subdev_ops ov7725_subdev_ops = {
+	.core	= &ov7725_subdev_core_ops,
+	.video	= &ov7725_subdev_video_ops,
+};
+
+/*
+ * i2c_driver function
+ */
+static int ov7725_probe(struct i2c_client *client,
+			const struct i2c_device_id *did)
+{
+        struct ov7725 *core;
+        struct v4l2_subdev *sd;
+	int ret;
+	u8 chip_id_high, chip_id_low;
+
+#ifdef CONFIG_MACH_IWG21M
+	struct device_node *np;
+	int cam0_pwr, cam2_pwr;
+	u32 status = -1;
+
+	np = of_find_compatible_node(NULL, NULL, "iwave,g21m-q7-com");
+	of_property_read_u32(np, "vin0-status", &status);
+	if(status) {
+		cam0_pwr = of_get_named_gpio(np, "cam0-pwr", 0);
+		if (gpio_is_valid(cam0_pwr) &&
+				!gpio_request_one(cam0_pwr, GPIOF_DIR_OUT, "cam0-pwr")) {
+			gpio_set_value(cam0_pwr, 1);
+			mdelay(100);
+			gpio_set_value(cam0_pwr, 0);
+		}
+	}
+	of_property_read_u32(np, "vin2-status", &status);
+	if(status) {
+		cam2_pwr = of_get_named_gpio(np, "cam2-pwr", 0);
+		if (gpio_is_valid(cam2_pwr) &&
+				!gpio_request_one(cam2_pwr, GPIOF_DIR_OUT, "cam2-pwr")) {
+			gpio_set_value(cam2_pwr, 1);
+			mdelay(100);
+			gpio_set_value(cam2_pwr, 0);
+		}
+	}
+#endif
+
+        /* Check if the adapter supports the needed features */
+        if (!i2c_check_functionality(client->adapter,
+             I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+                return -EIO;
+
+        core = kzalloc(sizeof(struct ov7725), GFP_KERNEL);
+        if (!core) {
+                return -ENOMEM;
+        }
+        sd = &core->sd;
+        v4l2_i2c_subdev_init(sd, client, &ov7725_subdev_ops);
+
+        chip_id_high = ov7725_read(sd, PID);
+        if (chip_id_high != 0x77) {
+                pr_warning("camera ov7725 is not found\n");
+                return -ENODEV;
+        }
+        chip_id_low = ov7725_read(sd, VER);
+        if (chip_id_low != 0x21) {
+                pr_warning("camera ov7725 is not found\n");
+                return -ENODEV;
+        }
+
+        v4l_info(client, "chip found @ 0x%02x (%s)\n",
+                 client->addr , client->adapter->name);
+	ret = ov7725_video_probe(sd);
+	if (ret) {
+                v4l2_info(sd, "camera ov7725 is not found.\n");
+                kfree(core);
+                return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int ov7725_remove(struct i2c_client *client)
+{
+        struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+        v4l2_dbg(1, debug, sd,
+                "ov7725.c: removing ov7725 adapter on address 0x%x\n",
+                client->addr << 1);
+
+        v4l2_device_unregister_subdev(sd);
+        kfree(to_ov7725(sd));
+        return 0;
+}
+
+static const struct i2c_device_id ov7725_id[] = {
+	{ "ov7725", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov7725_id);
+
+static struct i2c_driver ov7725_i2c_driver = {
+	.driver = {
+		.owner  = THIS_MODULE,
+		.name = "ov7725",
+	},
+	.probe    = ov7725_probe,
+	.remove   = ov7725_remove,
+	.id_table = ov7725_id,
+};
+
+/*
+ * module function
+ */
+
+static int __init ov7725_module_init(void)
+{
+	return i2c_add_driver(&ov7725_i2c_driver);
+}
+
+static void __exit ov7725_module_exit(void)
+{
+	i2c_del_driver(&ov7725_i2c_driver);
+}
+
+module_init(ov7725_module_init);
+module_exit(ov7725_module_exit);
+
+MODULE_DESCRIPTION("Camera driver for ov7725");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/tvp5150.c b/drivers/media/i2c/tvp5150.c
index 485159a..b3c2918 100644
--- a/drivers/media/i2c/tvp5150.c
+++ b/drivers/media/i2c/tvp5150.c
@@ -14,6 +14,11 @@
 #include <media/tvp5150.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-ctrls.h>
+#ifdef CONFIG_MACH_IWG21M
+/*IWG21M: TV-IN: Added include files for GPIO configuration and mbus configuration for soc_camera */
+#include <linux/of_gpio.h>
+#include <media/soc_camera.h>
+#endif
 
 #include "tvp5150_reg.h"
 
@@ -442,7 +447,10 @@ static const struct i2c_reg_value tvp5150_init_default[] = {
 /* Default values as sugested at TVP5150AM1 datasheet */
 static const struct i2c_reg_value tvp5150_init_enable[] = {
 	{
+#ifndef CONFIG_MACH_IWG21M
+        /*IWG21M: TV-IN: Commented register value to get the proper capture data from TVP5150 chip */
 		TVP5150_CONF_SHARED_PIN, 2
+#endif
 	},{	/* Automatic offset and AGC enabled */
 		TVP5150_ANAL_CHL_CTL, 0x15
 	},{	/* Activate YCrCb output 0x9 or 0xd ? */
@@ -456,7 +464,10 @@ static const struct i2c_reg_value tvp5150_init_enable[] = {
 	},{
 		TVP5150_CHROMA_PROC_CTL_2, 0x54
 	},{	/* Non documented, but initialized on WinTV USB2 */
+#ifndef CONFIG_MACH_IWG21M
+        /*IWG21M: TV-IN: Commented register value to get the proper capture data from TVP5150 chip */
 		0x27, 0x20
+#endif
 	},{
 		0xff,0xff
 	}
@@ -839,7 +850,12 @@ static int tvp5150_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned index,
 	if (index)
 		return -EINVAL;
 
+#ifdef CONFIG_MACH_IWG21M
+    /*IWG21M: TV-IN: Added controller supported code format */
+	*code = V4L2_MBUS_FMT_YUYV8_2X8;
+#else
 	*code = V4L2_MBUS_FMT_UYVY8_2X8;
+#endif
 	return 0;
 }
 
@@ -856,8 +872,13 @@ static int tvp5150_mbus_fmt(struct v4l2_subdev *sd,
 	f->width = decoder->rect.width;
 	f->height = decoder->rect.height;
 
+#ifdef CONFIG_MACH_IWG21M
+    /*IWG21M: TV-IN: Added controller supported format */
+	f->field = V4L2_FIELD_INTERLACED;
+	f->code = V4L2_MBUS_FMT_YUYV8_2X8;
+#else
 	f->code = V4L2_MBUS_FMT_UYVY8_2X8;
-	f->field = V4L2_FIELD_SEQ_TB;
+#endif
 	f->colorspace = V4L2_COLORSPACE_SMPTE170M;
 
 	v4l2_dbg(1, debug, sd, "width = %d, height = %d\n", f->width,
@@ -918,6 +939,22 @@ static int tvp5150_s_crop(struct v4l2_subdev *sd, const struct v4l2_crop *a)
 	return 0;
 }
 
+#ifdef CONFIG_MACH_IWG21M
+/*IWG21M: TV-IN: mbus configuration and protocol format for soc_camera */
+static int tvp5150_g_mbus_config(struct v4l2_subdev *sd,
+		struct v4l2_mbus_config *cfg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
+	cfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_MASTER |
+		V4L2_MBUS_VSYNC_ACTIVE_LOW | V4L2_MBUS_HSYNC_ACTIVE_LOW |
+		V4L2_MBUS_DATA_ACTIVE_HIGH;
+	cfg->type = V4L2_MBUS_BT656;
+	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
+	return 0;
+}
+#endif
+
 static int tvp5150_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)
 {
 	struct tvp5150 *decoder = container_of(sd, struct tvp5150, sd);
@@ -1118,6 +1155,10 @@ static const struct v4l2_subdev_video_ops tvp5150_video_ops = {
 	.s_crop = tvp5150_s_crop,
 	.g_crop = tvp5150_g_crop,
 	.cropcap = tvp5150_cropcap,
+#ifdef CONFIG_MACH_IWG21M
+    /*IWG21M: TV-IN: Inizilation for mbus configuration */
+	.g_mbus_config = tvp5150_g_mbus_config,
+#endif
 };
 
 static const struct v4l2_subdev_vbi_ops tvp5150_vbi_ops = {
@@ -1139,25 +1180,46 @@ static const struct v4l2_subdev_ops tvp5150_ops = {
 			I2C Client & Driver
  ****************************************************************************/
 
-static int tvp5150_probe(struct i2c_client *c,
-			 const struct i2c_device_id *id)
+/*
+ * tvp5150_init_controls() - Init controls
+ * @core: pointer to private state structure
+ *
+ * Init TVP5150 supported control handler.
+ */
+static int tvp5150_init_controls(struct tvp5150 *core)
 {
-	struct tvp5150 *core;
-	struct v4l2_subdev *sd;
-	int tvp5150_id[4];
-	int i, res;
+    v4l2_ctrl_handler_init(&core->hdl, 5);
+    v4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,
+            V4L2_CID_BRIGHTNESS, 0, 255, 1, 128);
+    v4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,
+            V4L2_CID_CONTRAST, 0, 255, 1, 128);
+    v4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,
+            V4L2_CID_SATURATION, 0, 255, 1, 128);
+    v4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,
+            V4L2_CID_HUE, -128, 127, 1, 0);
+    v4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,
+            V4L2_CID_PIXEL_RATE, 27000000,
+            27000000, 1, 27000000);
+    core->sd.ctrl_handler = &core->hdl;
+    if (core->hdl.error) {
+        int res = core->hdl.error;
+        v4l2_ctrl_handler_free(&core->hdl);
+        return res;
+    }
+    v4l2_ctrl_handler_setup(&core->hdl);
 
-	/* Check if the adapter supports the needed features */
-	if (!i2c_check_functionality(c->adapter,
-	     I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
-		return -EIO;
+	return 0;
+}
 
-	core = kzalloc(sizeof(struct tvp5150), GFP_KERNEL);
-	if (!core) {
-		return -ENOMEM;
-	}
-	sd = &core->sd;
-	v4l2_i2c_subdev_init(sd, c, &tvp5150_ops);
+static int tvp5150_detect_version(struct tvp5150 *core)
+{
+	struct v4l2_subdev *sd = &core->sd;
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	unsigned int i;
+	u16 dev_id;
+	u16 rom_ver;
+	u8 regs[4];
+	int res;
 
 	/* 
 	 * Read consequent registers - TVP5150_MSB_DEV_ID, TVP5150_LSB_DEV_ID,
@@ -1166,52 +1228,68 @@ static int tvp5150_probe(struct i2c_client *c,
 	for (i = 0; i < 4; i++) {
 		res = tvp5150_read(sd, TVP5150_MSB_DEV_ID + i);
 		if (res < 0)
-			goto free_core;
-		tvp5150_id[i] = res;
+			return res;
+		regs[i] = res;
 	}
 
-	v4l_info(c, "chip found @ 0x%02x (%s)\n",
-		 c->addr << 1, c->adapter->name);
+    dev_id = (regs[0] << 8) | regs[1];
+    rom_ver = (regs[2] << 8) | regs[3];
 
-	if (tvp5150_id[2] == 4 && tvp5150_id[3] == 0) { /* Is TVP5150AM1 */
-		v4l2_info(sd, "tvp%02x%02xam1 detected.\n",
-			  tvp5150_id[0], tvp5150_id[1]);
+	v4l2_info(sd, "tvp%04x (%u.%u) chip found @ 0x%02x (%s)\n",
+			dev_id, regs[2], regs[3], c->addr << 1, c->adapter->name);
+	if (dev_id == 0x5150 && rom_ver == 0x0321) { /* TVP51510A */
+		v4l2_info(sd, "tvp5150a detected.\n");
+	} else if (dev_id == 0x5150 && rom_ver == 0x0400) { /* TVP5150AM1 */
+		v4l2_info(sd, "tvp5150am1 detected.\n");
 
 		/* ITU-T BT.656.4 timing */
 		tvp5150_write(sd, TVP5150_REV_SELECT, 0);
 	} else {
-		/* Is TVP5150A */
-		if (tvp5150_id[2] == 3 || tvp5150_id[3] == 0x21) {
-			v4l2_info(sd, "tvp%02x%02xa detected.\n",
-				  tvp5150_id[2], tvp5150_id[3]);
-		} else {
-			v4l2_info(sd, "*** unknown tvp%02x%02x chip detected.\n",
-				  tvp5150_id[2], tvp5150_id[3]);
-			v4l2_info(sd, "*** Rom ver is %d.%d\n",
-				  tvp5150_id[2], tvp5150_id[3]);
-		}
+        v4l2_info(sd, "*** unknown tvp%04x chip detected.\n", dev_id);
+    }
+
+    return 0;
+}
+
+static int tvp5150_probe(struct i2c_client *c,
+			 const struct i2c_device_id *id)
+{
+	struct tvp5150 *core;
+	struct v4l2_subdev *sd;
+	struct device_node *np;
+	int res, pwrd_gpio;
+	np = of_find_compatible_node(NULL, NULL, "iwave,g21m-q7-com");
+	if (!np) {
+		pr_warn("failed to find g21m-q7-com node\n");
+		return -1;
+	}
+	pwrd_gpio = of_get_named_gpio(np, "tv-pwn", 0);
+	if (gpio_is_valid(pwrd_gpio) &&
+			!gpio_request_one(pwrd_gpio, GPIOF_DIR_OUT, "power-down")) {
+		gpio_set_value(pwrd_gpio, 1);
+		mdelay(100);
+	}
+	/* Check if the adapter supports the needed features */
+	if (!i2c_check_functionality(c->adapter,
+	     I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+		return -EIO;
+	core = kzalloc(sizeof(struct tvp5150), GFP_KERNEL);
+	if (!core) {
+		return -ENOMEM;
 	}
+	sd = &core->sd;
+	v4l2_i2c_subdev_init(sd, c, &tvp5150_ops);
+	res = tvp5150_detect_version(core);
+	if (res < 0)
+		goto free_core;
 
 	core->norm = V4L2_STD_ALL;	/* Default is autodetect */
 	core->input = TVP5150_COMPOSITE1;
 	core->enable = 1;
 
-	v4l2_ctrl_handler_init(&core->hdl, 4);
-	v4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,
-			V4L2_CID_BRIGHTNESS, 0, 255, 1, 128);
-	v4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,
-			V4L2_CID_CONTRAST, 0, 255, 1, 128);
-	v4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,
-			V4L2_CID_SATURATION, 0, 255, 1, 128);
-	v4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,
-			V4L2_CID_HUE, -128, 127, 1, 0);
-	sd->ctrl_handler = &core->hdl;
-	if (core->hdl.error) {
-		res = core->hdl.error;
-		v4l2_ctrl_handler_free(&core->hdl);
+	res=tvp5150_init_controls(core);
+	if (res)
 		goto free_core;
-	}
-	v4l2_ctrl_handler_setup(&core->hdl);
 
 	/* Default is no cropping */
 	core->rect.top = 0;
diff --git a/drivers/media/platform/soc_camera/rcar_vin.c b/drivers/media/platform/soc_camera/rcar_vin.c
index 1a1b111..1b99930 100644
--- a/drivers/media/platform/soc_camera/rcar_vin.c
+++ b/drivers/media/platform/soc_camera/rcar_vin.c
@@ -128,6 +128,7 @@
 #define VNDMR2_HPS		(1 << 29)
 #define VNDMR2_FTEV		(1 << 17)
 #define VNDMR2_VLV_1	(1 << 12)
+#define VNDMR2_YDS		(1 << 22)
 
 #define VIN_MAX_WIDTH		2048
 #define VIN_MAX_HEIGHT		2048
@@ -1261,6 +1262,8 @@ static int rcar_vin_set_bus_param(struct soc_camera_device *icd)
 		val |= VNDMR2_VPS;
 	if (!(common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW))
 		val |= VNDMR2_HPS;
+	if (priv->pdata->flags & RCAR_VIN2_G)
+		val |= VNDMR2_YDS;
 	iowrite32(val, priv->base + VNDMR2_REG);
 
 	ret = rcar_vin_set_rect(icd);
@@ -1884,6 +1887,7 @@ static struct soc_camera_host_ops rcar_vin_host_ops = {
 static struct platform_device_id rcar_vin_id_table[] = {
 	{ "r8a7745-vin",  RCAR_GEN2 },
 	{ "r8a7743-vin",  RCAR_GEN2 },
+	{ "r8a7742-vin",  RCAR_GEN2 },
 	{ "r8a7794-vin",  RCAR_GEN2 },
 	{ "r8a7793-vin",  RCAR_GEN2 },
 	{ "r8a7791-vin",  RCAR_GEN2 },
diff --git a/drivers/media/v4l2-core/v4l2-mem2mem.c b/drivers/media/v4l2-core/v4l2-mem2mem.c
index 7554bf6..e37aca3 100644
--- a/drivers/media/v4l2-core/v4l2-mem2mem.c
+++ b/drivers/media/v4l2-core/v4l2-mem2mem.c
@@ -828,4 +828,3 @@ unsigned int v4l2_m2m_fop_poll(struct file *file, poll_table *wait)
 	return ret;
 }
 EXPORT_SYMBOL_GPL(v4l2_m2m_fop_poll);
-
